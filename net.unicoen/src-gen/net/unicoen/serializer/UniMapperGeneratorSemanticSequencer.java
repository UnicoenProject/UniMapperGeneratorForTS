/*
 * generated by Xtext 2.13.0
 */
package net.unicoen.serializer;

import com.google.inject.Inject;
import java.util.Set;
import net.unicoen.services.UniMapperGeneratorGrammarAccess;
import net.unicoen.uniMapperGenerator.ActionElement;
import net.unicoen.uniMapperGenerator.ActionOption;
import net.unicoen.uniMapperGenerator.AltList;
import net.unicoen.uniMapperGenerator.Alternative;
import net.unicoen.uniMapperGenerator.Atom;
import net.unicoen.uniMapperGenerator.Block;
import net.unicoen.uniMapperGenerator.BlockSet;
import net.unicoen.uniMapperGenerator.Ebnf;
import net.unicoen.uniMapperGenerator.EbnfSuffix;
import net.unicoen.uniMapperGenerator.Element;
import net.unicoen.uniMapperGenerator.ElementOption;
import net.unicoen.uniMapperGenerator.ElementOptions;
import net.unicoen.uniMapperGenerator.EmptyTokens;
import net.unicoen.uniMapperGenerator.ExceptionGroup;
import net.unicoen.uniMapperGenerator.ExceptionHandler;
import net.unicoen.uniMapperGenerator.Exceptions;
import net.unicoen.uniMapperGenerator.FinallyClause;
import net.unicoen.uniMapperGenerator.Grammar;
import net.unicoen.uniMapperGenerator.GrammarAction;
import net.unicoen.uniMapperGenerator.Import;
import net.unicoen.uniMapperGenerator.Imports;
import net.unicoen.uniMapperGenerator.IntOption;
import net.unicoen.uniMapperGenerator.LabeledAlt;
import net.unicoen.uniMapperGenerator.LabeledElement;
import net.unicoen.uniMapperGenerator.LabeledLexerElement;
import net.unicoen.uniMapperGenerator.LexerAlt;
import net.unicoen.uniMapperGenerator.LexerAltList;
import net.unicoen.uniMapperGenerator.LexerAtom;
import net.unicoen.uniMapperGenerator.LexerBlock;
import net.unicoen.uniMapperGenerator.LexerCharSet;
import net.unicoen.uniMapperGenerator.LexerCommand;
import net.unicoen.uniMapperGenerator.LexerCommandExpr;
import net.unicoen.uniMapperGenerator.LexerCommands;
import net.unicoen.uniMapperGenerator.LexerElement;
import net.unicoen.uniMapperGenerator.LexerElementWithDollar;
import net.unicoen.uniMapperGenerator.LexerElements;
import net.unicoen.uniMapperGenerator.LexerRule;
import net.unicoen.uniMapperGenerator.LocalVars;
import net.unicoen.uniMapperGenerator.Mode;
import net.unicoen.uniMapperGenerator.NotSet;
import net.unicoen.uniMapperGenerator.Option;
import net.unicoen.uniMapperGenerator.Options;
import net.unicoen.uniMapperGenerator.QualifiedId;
import net.unicoen.uniMapperGenerator.QualifiedOption;
import net.unicoen.uniMapperGenerator.Range;
import net.unicoen.uniMapperGenerator.Return;
import net.unicoen.uniMapperGenerator.RuleAction;
import net.unicoen.uniMapperGenerator.RuleAltList;
import net.unicoen.uniMapperGenerator.RuleRef;
import net.unicoen.uniMapperGenerator.SetElement;
import net.unicoen.uniMapperGenerator.StringOption;
import net.unicoen.uniMapperGenerator.Terminal;
import net.unicoen.uniMapperGenerator.TokenVocab;
import net.unicoen.uniMapperGenerator.UniMapperGeneratorPackage;
import net.unicoen.uniMapperGenerator.UnicoenTypeDec;
import net.unicoen.uniMapperGenerator.UnicoenTypeIdentifiers;
import net.unicoen.uniMapperGenerator.V3Token;
import net.unicoen.uniMapperGenerator.V3Tokens;
import net.unicoen.uniMapperGenerator.V4Token;
import net.unicoen.uniMapperGenerator.V4Tokens;
import net.unicoen.uniMapperGenerator.Wildcard;
import net.unicoen.uniMapperGenerator.rootSelection;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class UniMapperGeneratorSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private UniMapperGeneratorGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == UniMapperGeneratorPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case UniMapperGeneratorPackage.ACTION_ELEMENT:
				sequence_ActionElement(context, (ActionElement) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.ACTION_OPTION:
				sequence_ActionOption(context, (ActionOption) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.ALT_LIST:
				sequence_AltList(context, (AltList) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.ALTERNATIVE:
				sequence_Alternative(context, (Alternative) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.ATOM:
				sequence_Atom(context, (Atom) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.BLOCK_SET:
				sequence_BlockSet(context, (BlockSet) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.EBNF:
				sequence_Ebnf(context, (Ebnf) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.EBNF_SUFFIX:
				sequence_EbnfSuffix(context, (EbnfSuffix) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.ELEMENT:
				sequence_Element(context, (Element) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.ELEMENT_OPTION:
				sequence_ElementOption(context, (ElementOption) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.ELEMENT_OPTIONS:
				sequence_ElementOptions(context, (ElementOptions) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.EMPTY_TOKENS:
				sequence_EmptyTokens(context, (EmptyTokens) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.EXCEPTION_GROUP:
				sequence_ExceptionGroup(context, (ExceptionGroup) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.EXCEPTION_HANDLER:
				sequence_ExceptionHandler(context, (ExceptionHandler) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.EXCEPTIONS:
				sequence_Exceptions(context, (Exceptions) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.FINALLY_CLAUSE:
				sequence_FinallyClause(context, (FinallyClause) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.GRAMMAR:
				sequence_Grammar(context, (Grammar) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.GRAMMAR_ACTION:
				sequence_GrammarAction(context, (GrammarAction) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.IMPORTS:
				sequence_Imports(context, (Imports) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.INT_OPTION:
				sequence_IntOption(context, (IntOption) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.LABELED_ALT:
				sequence_LabeledAlt(context, (LabeledAlt) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.LABELED_ELEMENT:
				sequence_LabeledElement(context, (LabeledElement) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.LABELED_LEXER_ELEMENT:
				sequence_LabeledLexerElement(context, (LabeledLexerElement) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.LEXER_ALT:
				sequence_LexerAlt(context, (LexerAlt) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.LEXER_ALT_LIST:
				sequence_LexerAltList(context, (LexerAltList) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.LEXER_ATOM:
				sequence_LexerAtom(context, (LexerAtom) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.LEXER_BLOCK:
				sequence_LexerBlock(context, (LexerBlock) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.LEXER_CHAR_SET:
				sequence_LexerCharSet(context, (LexerCharSet) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.LEXER_COMMAND:
				sequence_LexerCommand(context, (LexerCommand) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.LEXER_COMMAND_EXPR:
				sequence_LexerCommandExpr(context, (LexerCommandExpr) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.LEXER_COMMANDS:
				sequence_LexerCommands(context, (LexerCommands) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.LEXER_ELEMENT:
				sequence_LexerElement(context, (LexerElement) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.LEXER_ELEMENT_WITH_DOLLAR:
				sequence_LexerElementWithDollar(context, (LexerElementWithDollar) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.LEXER_ELEMENTS:
				sequence_LexerElements(context, (LexerElements) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.LEXER_RULE:
				sequence_LexerRule(context, (LexerRule) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.LOCAL_VARS:
				sequence_LocalVars(context, (LocalVars) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.MODE:
				sequence_Mode(context, (Mode) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.NOT_SET:
				sequence_NotSet(context, (NotSet) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.OPTION:
				sequence_Option(context, (Option) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.OPTIONS:
				sequence_Options(context, (Options) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.PARSER_RULE:
				sequence_ParserRule(context, (net.unicoen.uniMapperGenerator.ParserRule) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.QUALIFIED_ID:
				sequence_QualifiedId(context, (QualifiedId) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.QUALIFIED_OPTION:
				sequence_QualifiedOption(context, (QualifiedOption) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.RANGE:
				sequence_Range(context, (Range) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.RETURN:
				sequence_Return(context, (Return) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.RULE_ACTION:
				sequence_RuleAction(context, (RuleAction) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.RULE_ALT_LIST:
				sequence_RuleAltList(context, (RuleAltList) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.RULE_REF:
				sequence_RuleRef(context, (RuleRef) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.SET_ELEMENT:
				sequence_SetElement(context, (SetElement) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.STRING_OPTION:
				sequence_StringOption(context, (StringOption) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.TERMINAL:
				sequence_Terminal(context, (Terminal) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.TOKEN_VOCAB:
				sequence_TokenVocab(context, (TokenVocab) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.UNICOEN_TYPE_DEC:
				sequence_UnicoenTypeDec(context, (UnicoenTypeDec) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.UNICOEN_TYPE_IDENTIFIERS:
				sequence_UnicoenTypeIdentifiers(context, (UnicoenTypeIdentifiers) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.V3_TOKEN:
				sequence_V3Token(context, (V3Token) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.V3_TOKENS:
				sequence_V3Tokens(context, (V3Tokens) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.V4_TOKEN:
				sequence_V4Token(context, (V4Token) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.V4_TOKENS:
				sequence_V4Tokens(context, (V4Tokens) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.WILDCARD:
				sequence_Wildcard(context, (Wildcard) semanticObject); 
				return; 
			case UniMapperGeneratorPackage.ROOT_SELECTION:
				sequence_rootSelection(context, (rootSelection) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ActionElement returns ActionElement
	 *
	 * Constraint:
	 *     (body=ACTION options=ElementOptions?)
	 */
	protected void sequence_ActionElement(ISerializationContext context, ActionElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OptionValue returns ActionOption
	 *     ActionOption returns ActionOption
	 *
	 * Constraint:
	 *     value=ACTION
	 */
	protected void sequence_ActionOption(ISerializationContext context, ActionOption semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UniMapperGeneratorPackage.Literals.ACTION_OPTION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UniMapperGeneratorPackage.Literals.ACTION_OPTION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getActionOptionAccess().getValueACTIONTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AltList returns AltList
	 *
	 * Constraint:
	 *     (alternatives+=Alternative alternatives+=Alternative*)
	 */
	protected void sequence_AltList(ISerializationContext context, AltList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Alternative returns Alternative
	 *
	 * Constraint:
	 *     (options=ElementOptions? elements+=Element*)
	 */
	protected void sequence_Alternative(ISerializationContext context, Alternative semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Atom returns Atom
	 *
	 * Constraint:
	 *     (body=Range | body=Terminal | body=RuleRef | body=NotSet | body=Wildcard)
	 */
	protected void sequence_Atom(ISerializationContext context, Atom semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockSet returns BlockSet
	 *
	 * Constraint:
	 *     (elements+=SetElement elements+=SetElement*)
	 */
	protected void sequence_BlockSet(ISerializationContext context, BlockSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Block returns Block
	 *
	 * Constraint:
	 *     ((options=Options? actions+=RuleAction* colon=COLON)? body=AltList)
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EbnfSuffix returns EbnfSuffix
	 *
	 * Constraint:
	 *     ((operator='?' nongreedy='?'?) | (operator='*' nongreedy='?'?) | (operator='+' nongreedy='?'?))
	 */
	protected void sequence_EbnfSuffix(ISerializationContext context, EbnfSuffix semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Ebnf returns Ebnf
	 *
	 * Constraint:
	 *     (body=Block operator=EbnfSuffix?)
	 */
	protected void sequence_Ebnf(ISerializationContext context, Ebnf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementOption returns ElementOption
	 *
	 * Constraint:
	 *     (qualifiedId=QualifiedId | (id=Id assign='=' value=OptionValue))
	 */
	protected void sequence_ElementOption(ISerializationContext context, ElementOption semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementOptions returns ElementOptions
	 *
	 * Constraint:
	 *     (options+=ElementOption options+=ElementOption*)?
	 */
	protected void sequence_ElementOptions(ISerializationContext context, ElementOptions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Element
	 *
	 * Constraint:
	 *     ((body=LabeledElement operator=EbnfSuffix?) | (body=Atom operator=EbnfSuffix? op=Id?) | body=Ebnf | body=ActionElement)
	 */
	protected void sequence_Element(ISerializationContext context, Element semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrequelConstruct returns EmptyTokens
	 *     Tokens returns EmptyTokens
	 *     EmptyTokens returns EmptyTokens
	 *
	 * Constraint:
	 *     keyword=TOKENS_SPEC
	 */
	protected void sequence_EmptyTokens(ISerializationContext context, EmptyTokens semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UniMapperGeneratorPackage.Literals.TOKENS__KEYWORD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UniMapperGeneratorPackage.Literals.TOKENS__KEYWORD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEmptyTokensAccess().getKeywordTOKENS_SPECTerminalRuleCall_1_0(), semanticObject.getKeyword());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExceptionGroup returns ExceptionGroup
	 *
	 * Constraint:
	 *     (handlers+=ExceptionHandler* finally=FinallyClause?)
	 */
	protected void sequence_ExceptionGroup(ISerializationContext context, ExceptionGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExceptionHandler returns ExceptionHandler
	 *
	 * Constraint:
	 *     (exception=ARG_OR_CHARSET body=ACTION)
	 */
	protected void sequence_ExceptionHandler(ISerializationContext context, ExceptionHandler semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UniMapperGeneratorPackage.Literals.EXCEPTION_HANDLER__EXCEPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UniMapperGeneratorPackage.Literals.EXCEPTION_HANDLER__EXCEPTION));
			if (transientValues.isValueTransient(semanticObject, UniMapperGeneratorPackage.Literals.EXCEPTION_HANDLER__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UniMapperGeneratorPackage.Literals.EXCEPTION_HANDLER__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExceptionHandlerAccess().getExceptionARG_OR_CHARSETTerminalRuleCall_1_0(), semanticObject.getException());
		feeder.accept(grammarAccess.getExceptionHandlerAccess().getBodyACTIONTerminalRuleCall_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Exceptions returns Exceptions
	 *
	 * Constraint:
	 *     (exceptions+=QualifiedId exceptions+=QualifiedId*)
	 */
	protected void sequence_Exceptions(ISerializationContext context, Exceptions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FinallyClause returns FinallyClause
	 *
	 * Constraint:
	 *     body=ACTION
	 */
	protected void sequence_FinallyClause(ISerializationContext context, FinallyClause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UniMapperGeneratorPackage.Literals.FINALLY_CLAUSE__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UniMapperGeneratorPackage.Literals.FINALLY_CLAUSE__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFinallyClauseAccess().getBodyACTIONTerminalRuleCall_1_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PrequelConstruct returns GrammarAction
	 *     GrammarAction returns GrammarAction
	 *
	 * Constraint:
	 *     ((scope=ActionScope colonSymbol='::')? name=Id action=ACTION)
	 */
	protected void sequence_GrammarAction(ISerializationContext context, GrammarAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Grammar returns Grammar
	 *
	 * Constraint:
	 *     (
	 *         type=GrammarType? 
	 *         name=Id 
	 *         root=rootSelection 
	 *         prequels+=PrequelConstruct* 
	 *         rules+=Rule* 
	 *         modes+=Mode*
	 *     )
	 */
	protected void sequence_Grammar(ISerializationContext context, Grammar semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     ((alias=Id importURI=[Grammar|Id]) | importURI=[Grammar|Id])
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrequelConstruct returns Imports
	 *     Imports returns Imports
	 *
	 * Constraint:
	 *     (keyword='import' imports+=Import imports+=Import*)
	 */
	protected void sequence_Imports(ISerializationContext context, Imports semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OptionValue returns IntOption
	 *     IntOption returns IntOption
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_IntOption(ISerializationContext context, IntOption semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UniMapperGeneratorPackage.Literals.INT_OPTION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UniMapperGeneratorPackage.Literals.INT_OPTION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntOptionAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LabeledAlt returns LabeledAlt
	 *
	 * Constraint:
	 *     (body=Alternative label=Id?)
	 */
	protected void sequence_LabeledAlt(ISerializationContext context, LabeledAlt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LabeledElement returns LabeledElement
	 *
	 * Constraint:
	 *     (name=Id (op='=' | op='+=') (body=Atom | body=Block))
	 */
	protected void sequence_LabeledElement(ISerializationContext context, LabeledElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LabeledLexerElement returns LabeledLexerElement
	 *
	 * Constraint:
	 *     (label=Id (op='=' | op='+=') (body=LexerAtom | body=LexerBlock))
	 */
	protected void sequence_LabeledLexerElement(ISerializationContext context, LabeledLexerElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LexerAltList returns LexerAltList
	 *
	 * Constraint:
	 *     (alternatives+=LexerAlt alternatives+=LexerAlt*)
	 */
	protected void sequence_LexerAltList(ISerializationContext context, LexerAltList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LexerAlt returns LexerAlt
	 *
	 * Constraint:
	 *     (body=LexerElements commands=LexerCommands?)
	 */
	protected void sequence_LexerAlt(ISerializationContext context, LexerAlt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LexerAtom returns LexerAtom
	 *
	 * Constraint:
	 *     (
	 *         body=Range | 
	 *         body=Terminal | 
	 *         body=RuleRef | 
	 *         body=NotSet | 
	 *         body=Wildcard | 
	 *         body=LexerCharSet
	 *     )
	 */
	protected void sequence_LexerAtom(ISerializationContext context, LexerAtom semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LexerBlock returns LexerBlock
	 *
	 * Constraint:
	 *     (options=Options? body=LexerAltList)
	 */
	protected void sequence_LexerBlock(ISerializationContext context, LexerBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LexerCharSet returns LexerCharSet
	 *
	 * Constraint:
	 *     body=ARG_OR_CHARSET
	 */
	protected void sequence_LexerCharSet(ISerializationContext context, LexerCharSet semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UniMapperGeneratorPackage.Literals.LEXER_CHAR_SET__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UniMapperGeneratorPackage.Literals.LEXER_CHAR_SET__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLexerCharSetAccess().getBodyARG_OR_CHARSETTerminalRuleCall_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LexerCommandExpr returns LexerCommandExpr
	 *
	 * Constraint:
	 *     (ref=[LexerCommandArg|Id] | value=INT)
	 */
	protected void sequence_LexerCommandExpr(ISerializationContext context, LexerCommandExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LexerCommand returns LexerCommand
	 *
	 * Constraint:
	 *     ((name=LexerCommandName args=LexerCommandExpr) | name=LexerCommandName)
	 */
	protected void sequence_LexerCommand(ISerializationContext context, LexerCommand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LexerCommands returns LexerCommands
	 *
	 * Constraint:
	 *     (keyword=RARROW commands+=LexerCommand commands+=LexerCommand*)
	 */
	protected void sequence_LexerCommands(ISerializationContext context, LexerCommands semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LexerElementWithDollar returns LexerElementWithDollar
	 *
	 * Constraint:
	 *     (body=LexerElement op=Id?)
	 */
	protected void sequence_LexerElementWithDollar(ISerializationContext context, LexerElementWithDollar semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LexerElement returns LexerElement
	 *
	 * Constraint:
	 *     ((body=LabeledLexerElement operator=EbnfSuffix?) | (body=LexerAtom operator=EbnfSuffix?) | (body=LexerBlock operator=EbnfSuffix?) | body=ActionElement)
	 */
	protected void sequence_LexerElement(ISerializationContext context, LexerElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LexerElements returns LexerElements
	 *
	 * Constraint:
	 *     elements+=LexerElementWithDollar*
	 */
	protected void sequence_LexerElements(ISerializationContext context, LexerElements semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns LexerRule
	 *     TokenRef returns LexerRule
	 *     LexerRule returns LexerRule
	 *     LexerCommandArg returns LexerRule
	 *
	 * Constraint:
	 *     (fragment?='fragment'? name=TOKEN_REF type=UnicoenTypeDec? body=LexerAltList)
	 */
	protected void sequence_LexerRule(ISerializationContext context, LexerRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LocalVars returns LocalVars
	 *
	 * Constraint:
	 *     body=ARG_OR_CHARSET
	 */
	protected void sequence_LocalVars(ISerializationContext context, LocalVars semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UniMapperGeneratorPackage.Literals.LOCAL_VARS__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UniMapperGeneratorPackage.Literals.LOCAL_VARS__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLocalVarsAccess().getBodyARG_OR_CHARSETTerminalRuleCall_1_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Mode returns Mode
	 *     LexerCommandArg returns Mode
	 *
	 * Constraint:
	 *     (id=Id rules+=LexerRule*)
	 */
	protected void sequence_Mode(ISerializationContext context, Mode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NotSet returns NotSet
	 *
	 * Constraint:
	 *     (body=SetElement | body=BlockSet)
	 */
	protected void sequence_NotSet(ISerializationContext context, NotSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Option returns Option
	 *
	 * Constraint:
	 *     (name=Id value=OptionValue)
	 */
	protected void sequence_Option(ISerializationContext context, Option semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UniMapperGeneratorPackage.Literals.OPTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UniMapperGeneratorPackage.Literals.OPTION__NAME));
			if (transientValues.isValueTransient(semanticObject, UniMapperGeneratorPackage.Literals.OPTION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UniMapperGeneratorPackage.Literals.OPTION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOptionAccess().getNameIdParserRuleCall_1_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOptionAccess().getValueOptionValueParserRuleCall_1_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PrequelConstruct returns Options
	 *     Options returns Options
	 *     RulePrequel returns Options
	 *
	 * Constraint:
	 *     (keyword=OPTIONS_SPEC options+=Option*)
	 */
	protected void sequence_Options(ISerializationContext context, Options semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns ParserRule
	 *     ParserRule returns ParserRule
	 *
	 * Constraint:
	 *     (
	 *         name=RULE_REF 
	 *         args=ARG_OR_CHARSET? 
	 *         return=Return? 
	 *         throws=Exceptions? 
	 *         locals=LocalVars? 
	 *         prequels+=RulePrequel* 
	 *         type=UnicoenTypeDec? 
	 *         body=RuleAltList 
	 *         caught=ExceptionGroup 
	 *         semicolonSymbol=SEMICOLON
	 *     )
	 */
	protected void sequence_ParserRule(ISerializationContext context, net.unicoen.uniMapperGenerator.ParserRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     QualifiedId returns QualifiedId
	 *
	 * Constraint:
	 *     (name+=Id name+=Id*)
	 */
	protected void sequence_QualifiedId(ISerializationContext context, QualifiedId semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OptionValue returns QualifiedOption
	 *     QualifiedOption returns QualifiedOption
	 *
	 * Constraint:
	 *     value=QualifiedId
	 */
	protected void sequence_QualifiedOption(ISerializationContext context, QualifiedOption semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UniMapperGeneratorPackage.Literals.QUALIFIED_OPTION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UniMapperGeneratorPackage.Literals.QUALIFIED_OPTION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getQualifiedOptionAccess().getValueQualifiedIdParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Range returns Range
	 *
	 * Constraint:
	 *     (from=MYSTRING to=MYSTRING)
	 */
	protected void sequence_Range(ISerializationContext context, Range semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UniMapperGeneratorPackage.Literals.RANGE__FROM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UniMapperGeneratorPackage.Literals.RANGE__FROM));
			if (transientValues.isValueTransient(semanticObject, UniMapperGeneratorPackage.Literals.RANGE__TO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UniMapperGeneratorPackage.Literals.RANGE__TO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRangeAccess().getFromMYSTRINGTerminalRuleCall_0_0(), semanticObject.getFrom());
		feeder.accept(grammarAccess.getRangeAccess().getToMYSTRINGTerminalRuleCall_2_0(), semanticObject.getTo());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Return returns Return
	 *
	 * Constraint:
	 *     body=ARG_OR_CHARSET
	 */
	protected void sequence_Return(ISerializationContext context, Return semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UniMapperGeneratorPackage.Literals.RETURN__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UniMapperGeneratorPackage.Literals.RETURN__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReturnAccess().getBodyARG_OR_CHARSETTerminalRuleCall_1_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RulePrequel returns RuleAction
	 *     RuleAction returns RuleAction
	 *
	 * Constraint:
	 *     (name=Id body=ACTION)
	 */
	protected void sequence_RuleAction(ISerializationContext context, RuleAction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UniMapperGeneratorPackage.Literals.RULE_ACTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UniMapperGeneratorPackage.Literals.RULE_ACTION__NAME));
			if (transientValues.isValueTransient(semanticObject, UniMapperGeneratorPackage.Literals.RULE_ACTION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UniMapperGeneratorPackage.Literals.RULE_ACTION__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRuleActionAccess().getNameIdParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getRuleActionAccess().getBodyACTIONTerminalRuleCall_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RuleAltList returns RuleAltList
	 *
	 * Constraint:
	 *     (alternatives+=LabeledAlt alternatives+=LabeledAlt*)
	 */
	protected void sequence_RuleAltList(ISerializationContext context, RuleAltList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RuleRef returns RuleRef
	 *
	 * Constraint:
	 *     (reference=[ParserRule|RULE_REF] options=ElementOptions?)
	 */
	protected void sequence_RuleRef(ISerializationContext context, RuleRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SetElement returns SetElement
	 *
	 * Constraint:
	 *     (tokenRef=TOKEN_REF | stringLiteral=MYSTRING | range=Range | charSet=ARG_OR_CHARSET)
	 */
	protected void sequence_SetElement(ISerializationContext context, SetElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OptionValue returns StringOption
	 *     StringOption returns StringOption
	 *
	 * Constraint:
	 *     value=MYSTRING
	 */
	protected void sequence_StringOption(ISerializationContext context, StringOption semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UniMapperGeneratorPackage.Literals.STRING_OPTION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UniMapperGeneratorPackage.Literals.STRING_OPTION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringOptionAccess().getValueMYSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Terminal returns Terminal
	 *
	 * Constraint:
	 *     ((reference=[TokenRef|TOKEN_REF] options=ElementOptions?) | (literal=MYSTRING options=ElementOptions?) | eof='EOF2')
	 */
	protected void sequence_Terminal(ISerializationContext context, Terminal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Option returns TokenVocab
	 *     TokenVocab returns TokenVocab
	 *
	 * Constraint:
	 *     (name=TOKEN_VOCAB importURI=[Grammar|Id])
	 */
	protected void sequence_TokenVocab(ISerializationContext context, TokenVocab semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UniMapperGeneratorPackage.Literals.OPTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UniMapperGeneratorPackage.Literals.OPTION__NAME));
			if (transientValues.isValueTransient(semanticObject, UniMapperGeneratorPackage.Literals.TOKEN_VOCAB__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UniMapperGeneratorPackage.Literals.TOKEN_VOCAB__IMPORT_URI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTokenVocabAccess().getNameTOKEN_VOCABTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTokenVocabAccess().getImportURIGrammarIdParserRuleCall_2_0_1(), semanticObject.eGet(UniMapperGeneratorPackage.Literals.TOKEN_VOCAB__IMPORT_URI, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     UnicoenTypeDec returns UnicoenTypeDec
	 *
	 * Constraint:
	 *     type=UnicoenTypeIdentifiers
	 */
	protected void sequence_UnicoenTypeDec(ISerializationContext context, UnicoenTypeDec semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UniMapperGeneratorPackage.Literals.UNICOEN_TYPE_DEC__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UniMapperGeneratorPackage.Literals.UNICOEN_TYPE_DEC__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnicoenTypeDecAccess().getTypeUnicoenTypeIdentifiersParserRuleCall_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     UnicoenTypeIdentifiers returns UnicoenTypeIdentifiers
	 *
	 * Constraint:
	 *     ((name=Id typevalue=Id?) | ((dir='<' | dir='>') fieldvalue+=QualifiedId fieldvalue+=QualifiedId*))
	 */
	protected void sequence_UnicoenTypeIdentifiers(ISerializationContext context, UnicoenTypeIdentifiers semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     V3Token returns V3Token
	 *     TokenRef returns V3Token
	 *     LexerCommandArg returns V3Token
	 *
	 * Constraint:
	 *     (name=Id value=MYSTRING?)
	 */
	protected void sequence_V3Token(ISerializationContext context, V3Token semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrequelConstruct returns V3Tokens
	 *     Tokens returns V3Tokens
	 *     V3Tokens returns V3Tokens
	 *
	 * Constraint:
	 *     (keyword=TOKENS_SPEC tokens+=V3Token+)
	 */
	protected void sequence_V3Tokens(ISerializationContext context, V3Tokens semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     V4Token returns V4Token
	 *     TokenRef returns V4Token
	 *     LexerCommandArg returns V4Token
	 *
	 * Constraint:
	 *     name=Id
	 */
	protected void sequence_V4Token(ISerializationContext context, V4Token semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UniMapperGeneratorPackage.Literals.V4_TOKEN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UniMapperGeneratorPackage.Literals.V4_TOKEN__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getV4TokenAccess().getNameIdParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PrequelConstruct returns V4Tokens
	 *     Tokens returns V4Tokens
	 *     V4Tokens returns V4Tokens
	 *
	 * Constraint:
	 *     (keyword=TOKENS_SPEC tokens+=V4Token tokens+=V4Token*)
	 */
	protected void sequence_V4Tokens(ISerializationContext context, V4Tokens semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Wildcard returns Wildcard
	 *
	 * Constraint:
	 *     (dot='.' options=ElementOptions?)
	 */
	protected void sequence_Wildcard(ISerializationContext context, Wildcard semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     rootSelection returns rootSelection
	 *
	 * Constraint:
	 *     root=[ParserRule|RULE_REF]
	 */
	protected void sequence_rootSelection(ISerializationContext context, rootSelection semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UniMapperGeneratorPackage.Literals.ROOT_SELECTION__ROOT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UniMapperGeneratorPackage.Literals.ROOT_SELECTION__ROOT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRootSelectionAccess().getRootParserRuleRULE_REFTerminalRuleCall_1_0_1(), semanticObject.eGet(UniMapperGeneratorPackage.Literals.ROOT_SELECTION__ROOT, false));
		feeder.finish();
	}
	
	
}
