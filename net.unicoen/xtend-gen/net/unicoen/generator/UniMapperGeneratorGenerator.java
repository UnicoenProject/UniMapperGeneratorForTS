/**
 * generated by Xtext 2.13.0
 */
package net.unicoen.generator;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.common.collect.Iterators;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.HashSet;
import java.util.List;
import java.util.function.Consumer;
import net.unicoen.generator.ANTLRGrammarGenerator;
import net.unicoen.uniMapperGenerator.Atom;
import net.unicoen.uniMapperGenerator.Element;
import net.unicoen.uniMapperGenerator.Grammar;
import net.unicoen.uniMapperGenerator.LexerRule;
import net.unicoen.uniMapperGenerator.ParserRule;
import net.unicoen.uniMapperGenerator.QualifiedId;
import net.unicoen.uniMapperGenerator.RuleRef;
import net.unicoen.uniMapperGenerator.Terminal;
import net.unicoen.uniMapperGenerator.TokenRef;
import net.unicoen.uniMapperGenerator.UnicoenTypeDec;
import net.unicoen.util.InvokingStateAnalyzer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class UniMapperGeneratorGenerator extends AbstractGenerator {
  private String _grammarName;
  
  private InvokingStateAnalyzer _analyzer;
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    final ANTLRGrammarGenerator g4Generator = new ANTLRGrammarGenerator(fsa);
    final Procedure1<Grammar> _function = (Grammar it) -> {
      this._grammarName = this.toCamelCase(it.getName());
      final String parserCode = g4Generator.generate(this._grammarName, it);
      InvokingStateAnalyzer _invokingStateAnalyzer = new InvokingStateAnalyzer(parserCode, it);
      this._analyzer = _invokingStateAnalyzer;
      fsa.generateFile((this._grammarName + "Mapper.ts"), this.generateMapper(it));
    };
    IteratorExtensions.<Grammar>forEach(Iterators.<Grammar>filter(resource.getAllContents(), Grammar.class), _function);
  }
  
  public CharSequence generateImports() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("import CodeLocation from \'../../node_helper/CodeLocation\';");
    _builder.newLine();
    _builder.append("import CodeRange from \'../../node_helper/CodeRange\';");
    _builder.newLine();
    _builder.append("import UniNode from \'../../node/UniNode\';");
    _builder.newLine();
    _builder.append("import UniParam from \'../../node/UniParam\';");
    _builder.newLine();
    _builder.append("import UniEnhancedFor from \'../../node/UniEnhancedFor\';");
    _builder.newLine();
    _builder.append("import UniExpr from \'../../node/UniExpr\';");
    _builder.newLine();
    _builder.append("import UniArray from \'../../node/UniArray\';");
    _builder.newLine();
    _builder.append("import UniNumberLiteral from \'../../node/UniNumberLiteral\';");
    _builder.newLine();
    _builder.append("import UniBinOp from \'../../node/UniBinOp\';");
    _builder.newLine();
    _builder.append("import UniBlock from \'../../node/UniBlock\';");
    _builder.newLine();
    _builder.append("import UniBoolLiteral from \'../../node/UniBoolLiteral\';");
    _builder.newLine();
    _builder.append("import UniBreak from \'../../node/UniBreak\';");
    _builder.newLine();
    _builder.append("import UniCast from \'../../node/UniCast\';");
    _builder.newLine();
    _builder.append("import UniContinue from \'../../node/UniContinue\';");
    _builder.newLine();
    _builder.append("import UniClassDec from \'../../node/UniClassDec\';");
    _builder.newLine();
    _builder.append("import UniDecralation from \'../../node/UniDecralation\';");
    _builder.newLine();
    _builder.append("import UniDoWhile from \'../../node/UniDoWhile\';");
    _builder.newLine();
    _builder.append("import UniEmptyStatement from \'../../node/UniEmptyStatement\';");
    _builder.newLine();
    _builder.append("import UniFunctionDec from \'../../node/UniFunctionDec\';");
    _builder.newLine();
    _builder.append("import UniFor from \'../../node/UniFor\';");
    _builder.newLine();
    _builder.append("import UniIdent from \'../../node/UniIdent\';");
    _builder.newLine();
    _builder.append("import UniIf from \'../../node/UniIf\';");
    _builder.newLine();
    _builder.append("import UniIntLiteral from \'../../node/UniIntLiteral\';\t\t");
    _builder.newLine();
    _builder.append("import UniDoubleLiteral from \'../../node/UniDoubleLiteral\';");
    _builder.newLine();
    _builder.append("import UniCharacterLiteral from \'../../node/UniCharacterLiteral\';");
    _builder.newLine();
    _builder.append("import UniWhile from \'../../node/UniWhile\';");
    _builder.newLine();
    _builder.append("import UniUnaryOp from \'../../node/UniUnaryOp\';");
    _builder.newLine();
    _builder.append("import UniTernaryOp from \'../../node/UniTernaryOp\';");
    _builder.newLine();
    _builder.append("import UniNewArray from \'../../node/UniNewArray\';");
    _builder.newLine();
    _builder.append("import UniNew from \'../../node/UniNew\';");
    _builder.newLine();
    _builder.append("import UniStatement from \'../../node/UniStatement\';");
    _builder.newLine();
    _builder.append("import UniStringLiteral from \'../../node/UniStringLiteral\';");
    _builder.newLine();
    _builder.append("import UniReturn from \'../../node/UniReturn\';");
    _builder.newLine();
    _builder.append("import UniVariableDec from \'../../node/UniVariableDec\';");
    _builder.newLine();
    _builder.append("import UniVariableDef from \'../../node/UniVariableDef\';");
    _builder.newLine();
    _builder.append("import UniSwitchUnit from \'../../node/UniSwitchUnit\';");
    _builder.newLine();
    _builder.append("import UniSwitch from \'../../node/UniSwitch\';");
    _builder.newLine();
    _builder.append("import UniMethodCall from \'../../node/UniMethodCall\';");
    _builder.newLine();
    _builder.append("import UniProgram from \'../../node/UniProgram\';");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import { InputStream, CommonTokenStream, ParserRuleContext } from \'antlr4\';");
    _builder.newLine();
    _builder.append("import { Token }from \'antlr4/Token\';");
    _builder.newLine();
    _builder.append("import { RuleContext }from \'antlr4/RuleContext\';");
    _builder.newLine();
    _builder.append("import { TerminalNode, TerminalNodeImpl, RuleNode, ParseTree }from \'antlr4/tree/Tree\';");
    _builder.newLine();
    _builder.append("import { ");
    _builder.append(this._grammarName);
    _builder.append("Lexer } from \'./");
    _builder.append(this._grammarName);
    _builder.append("Lexer\';");
    _builder.newLineIfNotEmpty();
    _builder.append("import { ");
    _builder.append(this._grammarName);
    _builder.append("Parser } from \'./");
    _builder.append(this._grammarName);
    _builder.append("Parser\';");
    _builder.newLineIfNotEmpty();
    _builder.append("import { ");
    _builder.append(this._grammarName);
    _builder.append("Visitor } from \'./");
    _builder.append(this._grammarName);
    _builder.append("Visitor\';");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence generateMapper(final Grammar g) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("// tslint:disable");
    _builder.newLine();
    CharSequence _generateImports = this.generateImports();
    _builder.append(_generateImports);
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("class Comment {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("constructor(readonly contents:string[], public parent:ParseTree){");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("export default class ");
    _builder.append(this._grammarName);
    _builder.append("Mapper extends ");
    _builder.append(this._grammarName);
    _builder.append("Visitor {");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("private isDebugMode:boolean = false;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("private parser:");
    _builder.append(this._grammarName, "\t");
    _builder.append("Parser;");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("private _comments:Comment[] = [];");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("private _lastNode:UniNode;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("private _nextTokenIndex:number;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("private _stream:CommonTokenStream;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("setIsDebugMode(isDebugMode:boolean) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("this.isDebugMode = isDebugMode;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("getRawTree(code) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const chars = new InputStream(code);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const lexer = new ");
    _builder.append(this._grammarName, "\t\t");
    _builder.append("Lexer(chars);");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("const tokens = new CommonTokenStream(lexer);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("this.parser = new ");
    _builder.append(this._grammarName, "\t\t");
    _builder.append("Parser(tokens);");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("this.parser.buildParseTrees = true;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const tree = this.parser.translationunit();");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return [tree, this.parser];");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("parse(code) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return this.parseCore(new InputStream(code));");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("parseCore(chars) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const lexer = new ");
    _builder.append(this._grammarName, "\t\t");
    _builder.append("Lexer(chars);");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("const tokens = new CommonTokenStream(lexer);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("this.parser = new ");
    _builder.append(this._grammarName, "\t\t");
    _builder.append("Parser(tokens);");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("this.parser.buildParseTrees = true;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const tree = this.parser.");
    String _name = g.getRoot().getRoot().getName();
    _builder.append(_name, "\t\t");
    _builder.append("();");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("this._comments = [];");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("this._stream = tokens;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("this._lastNode = null;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("this._nextTokenIndex = 0;");
    _builder.newLine();
    {
      int _size = g.getRules().size();
      boolean _greaterThan = (_size > 0);
      if (_greaterThan) {
        _builder.append("\t\t");
        _builder.append("const ret = new UniProgram(this.visit(tree));");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("ret.codeRange = ret.block.codeRange;");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("if (this._lastNode !== null) {");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("\t");
        _builder.append("const count = this._stream.tokens.length - 1");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("\t");
        _builder.append("for (var i = this._nextTokenIndex; i < count; i++) {");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("\t\t");
        _builder.append("const hiddenToken = this._stream.tokens[i]; // Includes skipped tokens (maybe)");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("\t\t");
        _builder.append("if (this._lastNode.comments === null) {");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("\t\t\t");
        _builder.append("this._lastNode.comments = [];");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("\t\t");
        _builder.append("this._lastNode.comments += hiddenToken.text");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("return ret;");
        _builder.newLine();
      }
    }
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/*def parseFile(String path) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val inputStream = new FileInputStream(path)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("try {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("parseCore(new ANTLRInputStream(inputStream))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("} finally {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("inputStream.close");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def parseFile(String path, Function1<");
    _builder.append(this._grammarName, "\t");
    _builder.append("Parser, ParseTree> parseAction) {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("val inputStream = new FileInputStream(path)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("try {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("parseCore(new ANTLRInputStream(inputStream), parseAction)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("} finally {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("inputStream.close");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}*/");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public visitChildren(node:RuleNode) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const n = node.getChildCount();");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const list:any[] = [];");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (let i = 0; i < n;++i) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("const c = node.getChild(i);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("const childResult = this.visit(c);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("list.push(childResult);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const flatten = this.flatten(list);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return flatten;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public visit(tree:ParseTree) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const result = (() => {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if (!this.isDebugMode) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("return tree.accept(this);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t \t\t");
    _builder.append("if (!(tree instanceof RuleContext)) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("return tree.accept(this);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("const ruleName = this.getRuleName(tree);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("console.log(\'*** visit Rule : \' + ruleName + \' ***\');");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("const result = tree.accept(this);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("console.log(\'returned: \' + result);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("return result;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("})();");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const node = (Array.isArray(result) && result.length == 1) ? result[0] : result;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (node instanceof UniNode) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if(tree instanceof RuleContext) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("const start = tree.start;");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("const begin = new CodeLocation(start.column,start.line);");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("const stop = tree.stop;");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("const endPos = stop.column;");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("const length = 1 + stop.stop - stop.start;");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("const end = new CodeLocation(endPos + length, stop.line);");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("node.codeRange = new CodeRange(begin,end);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("let contents:string[]  = [];");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("for (let i = this._comments.length - 1; i >= 0 && this._comments[i].parent == tree; i--) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("for(const content of contents) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("this._comments[i].contents.push(content);");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("contents = this._comments[i].contents;");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("this._comments.splice(i, 1);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if (contents.length > 0) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("if (node.comments === null) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("node.comments = contents;");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("} else {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("node.comments = node.comments.concat(contents);");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("this._lastNode = node;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("} else {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("for (var i = this._comments.length - 1; i >= 0 && this._comments[i].parent == tree; i--) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("this._comments[i].parent = this._comments[i].parent.parent");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("this._lastNode = null");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return result;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("isNonEmptyNode(node:ParseTree):boolean {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (node instanceof ParserRuleContext) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("const n = node.getChildCount();");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if (n > 1) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("return true;");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("// n === 1 && node.children.exists[isNonEmptyNode]");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("return n === 1;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("} else {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("return true;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("getRuleName(node) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return this.parser.ruleNames[node.ruleIndex];");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public visitTerminal(node:TerminalNode) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (this.isDebugMode) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("console.log(\"visit TERMINAL : \" + node.text);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const token = node.symbol;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (token.type > 0) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("const count = token.tokenIndex;");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("const contents:string[] = [];");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("let i = this._nextTokenIndex;");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("for (; i < count; i++) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("const hiddenToken = this._stream.tokens[i]; // Includes skipped tokens (maybe)");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("if (this._lastNode !== null && this._stream.tokens[this._nextTokenIndex - 1].line == hiddenToken.line) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("if (this._lastNode.comments === null) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t");
    _builder.append("this._lastNode.comments = [];");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("this._lastNode.comments += hiddenToken.text;");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("} else {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("contents.push(hiddenToken.text);");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("const count2 = this._stream.tokens.length - 1;");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("for (i = count + 1; i < count2 && this._stream.tokens[i].channel == Token.HIDDEN_CHANNEL &&");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("this._stream.tokens[count].line == this._stream.tokens[i].line; i++) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("contents.push(this._stream.tokens[i].text);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if (contents.length > 0) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("this._comments.push(new Comment(contents, node.parent));");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("this._nextTokenIndex = i;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return token.text;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("private flatten(obj:any) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (Array.isArray(obj)) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if (obj.length === 1) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("return this.flatten(obj[0]);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("const ret = [];");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("obj.forEach((it:any) => {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("ret.push(this.flatten(it));");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("});");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("return ret;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (obj instanceof Map) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if (obj.size === 1) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("for (const value of obj.values()) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("return this.flatten(value);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("const ret = new Map<any, any>();");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("obj.forEach((value: any, key: any) => {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("ret.set(key, this.flatten(value));");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("});");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("return ret;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return obj;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public castToList<T extends Function|String>(obj:any, clazz:T):T[] {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const temp = this.flatten(obj);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const ret = [];");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (temp instanceof Map) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const add = temp.has(\'add\');");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("temp.forEach((value: any, key: any) => {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("switch (key) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("case \'add\': {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("if (value instanceof Map) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("ret.push(this.castTo<T>(value, clazz));");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("} else if (Array.isArray(value)) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("value.forEach((it:any) => {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("const t = this.castTo(it, clazz);");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("if (t != null) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("ret.push(t);");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("});");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("} else {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("ret.push(this.castToList(value, clazz));");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("} ");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("break;");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("default:");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("if (!add) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("ret.push(this.castToList(value, clazz));");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("break;");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("});");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("} else if (Array.isArray(temp)) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("temp.forEach((it:any) => {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("ret.push(this.castToList(it, clazz));");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("});");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("} else {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("ret.push(this.castTo(temp, clazz));");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return ret;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public castTo<T extends Function|String>(obj:any, clazz:any) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const temp = this.flatten(obj);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const instance = new clazz();");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const fields = instance.fields;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const fieldsName = [];");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (let it in instance) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("fieldsName.push(it);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (temp instanceof Map) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (clazz === String) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("let builder = \'\';");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("const hasAdd = temp.has(\'add\');");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("temp.forEach((value: any, key: any) => {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("switch (key) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("case \'add\': {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("builder += this.castTo<T>(value, clazz);");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("break;");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("default: {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("if (!hasAdd) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("builder += this.castTo<T>(value, clazz);");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("break;");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("});");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("return (builder.length > 0) ? builder : null;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("temp.forEach((value: any, key: any) => {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if (fieldsName.includes(key)) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("const field:Function = fields.get(key);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if (Array.isArray(instance[key])) {");
    _builder.newLine();
    _builder.append("\t\t\t \t\t");
    _builder.append("const list\t= this.flatten(this.castToList(value, field));");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("if(!Array.isArray(list)) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("instance[key] = [list];");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("} else {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("instance[key] = list;");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("} else if (value.length == 0");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("&& (field == UniExpr || field == UniStatement )){");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("instance[key] = null;");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("} else {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("instance[key] = this.castTo(value, field);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("});");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return instance;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (Array.isArray(temp)) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (clazz === String) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("let builder = \'\';");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("temp.forEach((it:any) => {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("builder += (this.castTo(it, clazz));");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("});");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("return (builder.length > 0) ? builder : null;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const first = temp.find((it) => {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("return it instanceof clazz;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("});");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (first === null) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("try {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("return instance;");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("} catch (e) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("return null;");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("} else {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("return this.castTo<T>(first,clazz);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if(temp != null) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return temp as T;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return instance;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    {
      Iterable<ParserRule> _filter = Iterables.<ParserRule>filter(g.getRules(), ParserRule.class);
      for(final ParserRule r : _filter) {
        {
          if ((((r.getType() != null) && (r.getType().getType().getName() != null)) && r.getType().getType().getName().endsWith("Literal"))) {
            _builder.append("\t");
            CharSequence _makeLiteralMethod = this.makeLiteralMethod(r);
            _builder.append(_makeLiteralMethod, "\t");
            _builder.newLineIfNotEmpty();
            _builder.newLine();
          } else {
            if (((r.getType() != null) || (IteratorExtensions.<Element>findFirst(Iterators.<Element>filter(r.eAllContents(), Element.class), ((Function1<Element, Boolean>) (Element it) -> {
              String _op = it.getOp();
              return Boolean.valueOf((_op != null));
            })) != null))) {
              _builder.append("\t");
              CharSequence _makeVisitMethod = this.makeVisitMethod(r);
              _builder.append(_makeVisitMethod, "\t");
              _builder.newLineIfNotEmpty();
              _builder.newLine();
            }
          }
        }
      }
    }
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  public String toCamelCase(final String str) {
    char _upperCase = Character.toUpperCase(str.charAt(0));
    String _substring = str.substring(1);
    return (Character.valueOf(_upperCase) + _substring);
  }
  
  public CharSequence makeVisitMethod(final ParserRule r) {
    CharSequence _xblockexpression = null;
    {
      final String ruleName = this.toCamelCase(r.getName());
      String _xifexpression = null;
      UnicoenTypeDec _type = r.getType();
      boolean _tripleNotEquals = (_type != null);
      if (_tripleNotEquals) {
        _xifexpression = r.getType().getType().getName();
      } else {
        _xifexpression = new String();
      }
      final String typeName = _xifexpression;
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("public visit");
      _builder.append(ruleName);
      _builder.append("(ctx:");
      _builder.append(this._grammarName);
      _builder.append("Parser.");
      _builder.append(ruleName);
      _builder.append("Context) {");
      _builder.newLineIfNotEmpty();
      {
        boolean _equals = Objects.equal(typeName, "List");
        if (_equals) {
          _builder.append("\t");
          CharSequence _makeListMethodBody = this.makeListMethodBody(r, r.getType().getType().getTypevalue());
          _builder.append(_makeListMethodBody, "\t");
          _builder.newLineIfNotEmpty();
        } else {
          _builder.append("\t");
          CharSequence _makeMethodBody = this.makeMethodBody(r);
          _builder.append(_makeMethodBody, "\t");
          _builder.newLineIfNotEmpty();
        }
      }
      _builder.append("}");
      _builder.newLine();
      _xblockexpression = _builder;
    }
    return _xblockexpression;
  }
  
  public CharSequence makeMethodBody(final ParserRule r) {
    CharSequence _xblockexpression = null;
    {
      final HashSet<String> annotationList = CollectionLiterals.<String>newHashSet();
      final Function1<Element, Boolean> _function = (Element it) -> {
        String _op = it.getOp();
        return Boolean.valueOf((_op != null));
      };
      final List<Element> elementList = IteratorExtensions.<Element>toList(IteratorExtensions.<Element>filter(Iterators.<Element>filter(r.eAllContents(), Element.class), _function));
      final Function1<Element, Boolean> _function_1 = (Element it) -> {
        String _op = it.getOp();
        return Boolean.valueOf(Objects.equal(_op, "MERGE"));
      };
      Element _findFirst = IterableExtensions.<Element>findFirst(elementList, _function_1);
      final boolean hasMerge = (_findFirst != null);
      final Function1<Element, Boolean> _function_2 = (Element it) -> {
        String _op = it.getOp();
        return Boolean.valueOf(Objects.equal(_op, "RETURN"));
      };
      Element _findFirst_1 = IterableExtensions.<Element>findFirst(elementList, _function_2);
      final boolean hasReturn = (_findFirst_1 != null);
      final Consumer<Element> _function_3 = (Element it) -> {
        String _op = it.getOp();
        annotationList.add(_op);
      };
      elementList.forEach(_function_3);
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("const map = new Map<string,any>();");
      _builder.newLine();
      _builder.append("const none = [];");
      _builder.newLine();
      _builder.append("map.set(\"none\", none);");
      _builder.newLine();
      {
        for(final String it : annotationList) {
          {
            boolean _notEquals = (!Objects.equal(it, "MERGE"));
            if (_notEquals) {
              _builder.append("const ");
              String _xifexpression = null;
              boolean _equals = Objects.equal(it, "ADD");
              if (_equals) {
                _xifexpression = it.toLowerCase();
              } else {
                String _xifexpression_1 = null;
                boolean _equals_1 = Objects.equal(it, "RETURN");
                if (_equals_1) {
                  _xifexpression_1 = "ret";
                } else {
                  _xifexpression_1 = it;
                }
                _xifexpression = _xifexpression_1;
              }
              _builder.append(_xifexpression);
              _builder.append(" = [];");
              _builder.newLineIfNotEmpty();
              {
                boolean _notEquals_1 = (!Objects.equal(it, "RETURN"));
                if (_notEquals_1) {
                  _builder.append("map.set(\"");
                  String _xifexpression_2 = null;
                  boolean _equals_2 = Objects.equal(it, "ADD");
                  if (_equals_2) {
                    _xifexpression_2 = it.toLowerCase();
                  } else {
                    _xifexpression_2 = it;
                  }
                  _builder.append(_xifexpression_2);
                  _builder.append("\", ");
                  String _xifexpression_3 = null;
                  boolean _equals_3 = Objects.equal(it, "ADD");
                  if (_equals_3) {
                    _xifexpression_3 = it.toLowerCase();
                  } else {
                    _xifexpression_3 = it;
                  }
                  _builder.append(_xifexpression_3);
                  _builder.append(");");
                  _builder.newLineIfNotEmpty();
                }
              }
            }
          }
        }
      }
      {
        if (hasMerge) {
          _builder.append("const merge = [];");
          _builder.newLine();
        }
      }
      _builder.append("const n = ctx.getChildCount();");
      _builder.newLine();
      _builder.append("for (let i = 0; i < n;++i) {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("const it = ctx.getChild(i);\t");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("if (it instanceof RuleContext) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("switch (it.invokingState) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      final HashSet<Integer> stateList = CollectionLiterals.<Integer>newHashSet();
      _builder.newLineIfNotEmpty();
      {
        for(final Element it_1 : elementList) {
          _builder.append("\t\t\t");
          final EObject atom = it_1.getBody();
          _builder.newLineIfNotEmpty();
          {
            if ((atom instanceof Atom)) {
              _builder.append("\t\t\t");
              final EObject ref = ((Atom)atom).getBody();
              _builder.newLineIfNotEmpty();
              {
                if ((ref instanceof RuleRef)) {
                  _builder.append("\t\t\t");
                  final Integer invokingState = this.getInvokingState(r);
                  _builder.newLineIfNotEmpty();
                  {
                    boolean _add = stateList.add(invokingState);
                    if (_add) {
                      _builder.append("\t\t\t");
                      _builder.append("case ");
                      _builder.append(invokingState, "\t\t\t");
                      _builder.append(": {");
                      _builder.newLineIfNotEmpty();
                      _builder.append("\t\t\t");
                      _builder.append("\t");
                      String _xifexpression_4 = null;
                      if ((Objects.equal(it_1.getOp(), "MERGE") || Objects.equal(it_1.getOp(), "ADD"))) {
                        _xifexpression_4 = it_1.getOp().toLowerCase();
                      } else {
                        String _xifexpression_5 = null;
                        String _op = it_1.getOp();
                        boolean _equals_4 = Objects.equal(_op, "RETURN");
                        if (_equals_4) {
                          _xifexpression_5 = "ret";
                        } else {
                          _xifexpression_5 = it_1.getOp();
                        }
                        _xifexpression_4 = _xifexpression_5;
                      }
                      _builder.append(_xifexpression_4, "\t\t\t\t");
                      _builder.append(".push(");
                      {
                        if (((r.getType() != null) && (r.getType().getType().getDir() != null))) {
                          _builder.append("this.flatten(");
                        }
                      }
                      _builder.append("this.visit(it)");
                      {
                        if (((r.getType() != null) && (r.getType().getType().getDir() != null))) {
                          _builder.append(")");
                        }
                      }
                      _builder.append(");");
                      _builder.newLineIfNotEmpty();
                      _builder.append("\t\t\t");
                      _builder.append("}");
                      _builder.newLine();
                      _builder.append("\t\t\t");
                      _builder.append("break;");
                      _builder.newLine();
                    }
                  }
                }
              }
            }
          }
        }
      }
      _builder.append("\t\t\t");
      _builder.append("default: {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("none.push(this.visit(it));");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("break;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("} else if (it instanceof TerminalNode) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("switch (it.symbol.type) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      final HashSet<String> nameList = CollectionLiterals.<String>newHashSet();
      _builder.newLineIfNotEmpty();
      {
        for(final Element it_2 : elementList) {
          _builder.append("\t\t\t");
          final EObject atom_1 = it_2.getBody();
          _builder.newLineIfNotEmpty();
          {
            if ((atom_1 instanceof Atom)) {
              _builder.append("\t\t\t");
              final EObject ref_1 = ((Atom)atom_1).getBody();
              _builder.newLineIfNotEmpty();
              {
                if (((ref_1 instanceof Terminal) && nameList.add(this.getTerminalName(it_2)))) {
                  _builder.append("\t\t\t");
                  _builder.append("case ");
                  _builder.append(this._grammarName, "\t\t\t");
                  _builder.append("Parser.");
                  String _terminalName = this.getTerminalName(it_2);
                  _builder.append(_terminalName, "\t\t\t");
                  _builder.append(": {");
                  _builder.newLineIfNotEmpty();
                  _builder.append("\t\t\t");
                  _builder.append("\t");
                  String _xifexpression_6 = null;
                  if ((Objects.equal(it_2.getOp(), "MERGE") || Objects.equal(it_2.getOp(), "ADD"))) {
                    _xifexpression_6 = it_2.getOp().toLowerCase();
                  } else {
                    String _xifexpression_7 = null;
                    String _op_1 = it_2.getOp();
                    boolean _equals_5 = Objects.equal(_op_1, "RETURN");
                    if (_equals_5) {
                      _xifexpression_7 = "ret";
                    } else {
                      _xifexpression_7 = it_2.getOp();
                    }
                    _xifexpression_6 = _xifexpression_7;
                  }
                  _builder.append(_xifexpression_6, "\t\t\t\t");
                  _builder.append(".push(this.flatten(this.visit(it)));");
                  _builder.newLineIfNotEmpty();
                  _builder.append("\t\t\t");
                  _builder.append("}");
                  _builder.newLine();
                  _builder.append("\t\t\t");
                  _builder.append("break;");
                  _builder.newLine();
                }
              }
            }
          }
        }
      }
      _builder.append("\t\t\t");
      _builder.append("default: {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("none.push(this.visit(it));");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("break;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      {
        if (hasReturn) {
          _builder.append("if (!ret.isEmpty()) {");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("return ret;");
          _builder.newLine();
          _builder.append("}");
          _builder.newLine();
        }
      }
      {
        UnicoenTypeDec _type = r.getType();
        boolean _tripleNotEquals = (_type != null);
        if (_tripleNotEquals) {
          {
            String _name = r.getType().getType().getName();
            boolean _tripleNotEquals_1 = (_name != null);
            if (_tripleNotEquals_1) {
              _builder.append("let node = this.castTo(map, ");
              String _name_1 = r.getType().getType().getName();
              _builder.append(_name_1);
              _builder.append(");");
              _builder.newLineIfNotEmpty();
              {
                if (hasMerge) {
                  _builder.append("if(typeof node === \'object\' && \'merge\' in node){");
                  _builder.newLine();
                  _builder.append("\t");
                  _builder.append("merge.forEach((it:any) => { node.merge(this.castTo(it, ");
                  String _name_2 = r.getType().getType().getName();
                  _builder.append(_name_2, "\t");
                  _builder.append("));});");
                  _builder.newLineIfNotEmpty();
                  _builder.append("} else {");
                  _builder.newLine();
                  _builder.append("\t");
                  _builder.append("node = new ");
                  String _name_3 = r.getType().getType().getName();
                  _builder.append(_name_3, "\t");
                  _builder.append("();");
                  _builder.newLineIfNotEmpty();
                  _builder.append("\t");
                  _builder.append("merge.forEach((it:any) => { node.merge(this.castTo(it, ");
                  String _name_4 = r.getType().getType().getName();
                  _builder.append(_name_4, "\t");
                  _builder.append("));});");
                  _builder.newLineIfNotEmpty();
                  _builder.append("}");
                  _builder.newLine();
                }
              }
              _builder.append("return node;");
              _builder.newLine();
            } else {
              {
                String _dir = r.getType().getType().getDir();
                boolean _equals_6 = Objects.equal(_dir, ">");
                if (_equals_6) {
                  _builder.append("add.reverse();");
                  _builder.newLine();
                }
              }
              _builder.append("const node = add[0] as UniExpr;");
              _builder.newLine();
              _builder.append("for (Object obj : add) {");
              _builder.newLine();
              _builder.append("\t");
              _builder.append("switch (obj) {");
              _builder.newLine();
              {
                EList<QualifiedId> _fieldvalue = r.getType().getType().getFieldvalue();
                for(final QualifiedId field : _fieldvalue) {
                  _builder.append("\t\t");
                  String _get = field.getName().get(0);
                  _builder.append(_get, "\t\t");
                  _builder.append(": {");
                  _builder.newLineIfNotEmpty();
                  _builder.append("\t\t");
                  _builder.append("\t");
                  _builder.append("obj.");
                  String _get_1 = field.getName().get(1);
                  _builder.append(_get_1, "\t\t\t");
                  _builder.append(" = node");
                  _builder.newLineIfNotEmpty();
                  _builder.append("\t\t");
                  _builder.append("\t");
                  _builder.append("node = obj");
                  _builder.newLine();
                  _builder.append("\t\t");
                  _builder.append("}");
                  _builder.newLine();
                }
              }
              _builder.append("\t");
              _builder.append("}");
              _builder.newLine();
              _builder.append("}");
              _builder.newLine();
              _builder.append("return node;");
              _builder.newLine();
            }
          }
        } else {
          {
            if (hasMerge) {
              _builder.append("merge.forEach [");
              _builder.newLine();
              _builder.append("\t");
              _builder.append("if (it instanceof Map<?, ?>) {");
              _builder.newLine();
              _builder.append("\t\t");
              _builder.append("it.forEach [ k, v |");
              _builder.newLine();
              _builder.append("\t\t\t");
              _builder.append("if (map.containsKey(k)) {");
              _builder.newLine();
              _builder.append("\t\t\t\t");
              _builder.append("map.get(k) += v");
              _builder.newLine();
              _builder.append("\t\t\t");
              _builder.append("} else {");
              _builder.newLine();
              _builder.append("\t\t\t\t");
              _builder.append("map.put(k, v as ArrayList<Object>)");
              _builder.newLine();
              _builder.append("\t\t\t");
              _builder.append("}");
              _builder.newLine();
              _builder.append("\t\t");
              _builder.append("]");
              _builder.newLine();
              _builder.append("\t");
              _builder.append("}");
              _builder.newLine();
              _builder.append("]");
              _builder.newLine();
            }
          }
          _builder.append("return map;");
          _builder.newLine();
        }
      }
      _xblockexpression = _builder;
    }
    return _xblockexpression;
  }
  
  public String getReferenceReturnType(final Element r) {
    String _xblockexpression = null;
    {
      EObject _body = r.getBody();
      final EObject ref = ((Atom) _body).getBody();
      String _xifexpression = null;
      if ((ref instanceof RuleRef)) {
        String _xifexpression_1 = null;
        UnicoenTypeDec _type = ((RuleRef)ref).getReference().getType();
        boolean _tripleNotEquals = (_type != null);
        if (_tripleNotEquals) {
          _xifexpression_1 = ((RuleRef)ref).getReference().getType().getType().getName();
        }
        _xifexpression = _xifexpression_1;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  public String getTerminalName(final Element r) {
    String _xblockexpression = null;
    {
      EObject _body = r.getBody();
      final EObject ref = ((Atom) _body).getBody();
      String _xifexpression = null;
      if ((ref instanceof Terminal)) {
        TokenRef _reference = ((Terminal)ref).getReference();
        _xifexpression = ((LexerRule) _reference).getName();
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  public String getTypeName(final Type type) {
    boolean _matched = false;
    if (type instanceof Class) {
      _matched=true;
      return ((Class<?>)type).getName();
    }
    if (!_matched) {
      if (type instanceof ParameterizedType) {
        _matched=true;
        final StringBuilder sb = new StringBuilder();
        sb.append(((ParameterizedType)type).getTypeName()).append("<");
        boolean isFirst = true;
        Type[] _actualTypeArguments = ((ParameterizedType)type).getActualTypeArguments();
        for (final Type arg : _actualTypeArguments) {
          {
            if ((!isFirst)) {
              sb.append(",");
            }
            sb.append(arg.getTypeName());
          }
        }
        sb.append(">");
        return sb.toString();
      }
    }
    String _string = type.toString();
    String _plus = ("Unknown type:" + _string);
    this.die(_plus);
    return null;
  }
  
  public CharSequence makeListMethodBody(final ParserRule r, final String itemClassName) {
    CharSequence _xblockexpression = null;
    {
      final HashSet<String> annotationList = CollectionLiterals.<String>newHashSet();
      final Function1<Element, Boolean> _function = (Element it) -> {
        String _op = it.getOp();
        return Boolean.valueOf((_op != null));
      };
      final List<Element> elementList = IteratorExtensions.<Element>toList(IteratorExtensions.<Element>filter(Iterators.<Element>filter(r.eAllContents(), Element.class), _function));
      final Function1<Element, Boolean> _function_1 = (Element it) -> {
        String _op = it.getOp();
        return Boolean.valueOf(Objects.equal(_op, "MERGE"));
      };
      Element _findFirst = IterableExtensions.<Element>findFirst(elementList, _function_1);
      final boolean hasMerge = (_findFirst != null);
      final Function1<Element, Boolean> _function_2 = (Element it) -> {
        String _op = it.getOp();
        return Boolean.valueOf(Objects.equal(_op, "RETURN"));
      };
      Element _findFirst_1 = IterableExtensions.<Element>findFirst(elementList, _function_2);
      final boolean hasReturn = (_findFirst_1 != null);
      final Consumer<Element> _function_3 = (Element it) -> {
        String _op = it.getOp();
        annotationList.add(_op);
      };
      elementList.forEach(_function_3);
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("const map = new Map<string,any>();");
      _builder.newLine();
      _builder.append("const none = [];");
      _builder.newLine();
      _builder.append("map.set(\"none\", none);");
      _builder.newLine();
      {
        for(final String it : annotationList) {
          {
            boolean _notEquals = (!Objects.equal(it, "MERGE"));
            if (_notEquals) {
              _builder.append("const ");
              String _xifexpression = null;
              boolean _equals = Objects.equal(it, "ADD");
              if (_equals) {
                _xifexpression = it.toLowerCase();
              } else {
                String _xifexpression_1 = null;
                boolean _equals_1 = Objects.equal(it, "RETURN");
                if (_equals_1) {
                  _xifexpression_1 = "ret";
                } else {
                  _xifexpression_1 = it;
                }
                _xifexpression = _xifexpression_1;
              }
              _builder.append(_xifexpression);
              _builder.append(" = [];");
              _builder.newLineIfNotEmpty();
              {
                boolean _notEquals_1 = (!Objects.equal(it, "RETURN"));
                if (_notEquals_1) {
                  _builder.append("map.set(\"");
                  String _xifexpression_2 = null;
                  boolean _equals_2 = Objects.equal(it, "ADD");
                  if (_equals_2) {
                    _xifexpression_2 = it.toLowerCase();
                  } else {
                    _xifexpression_2 = it;
                  }
                  _builder.append(_xifexpression_2);
                  _builder.append("\", ");
                  String _xifexpression_3 = null;
                  boolean _equals_3 = Objects.equal(it, "ADD");
                  if (_equals_3) {
                    _xifexpression_3 = it.toLowerCase();
                  } else {
                    _xifexpression_3 = it;
                  }
                  _builder.append(_xifexpression_3);
                  _builder.append(");");
                  _builder.newLineIfNotEmpty();
                }
              }
            }
          }
        }
      }
      {
        if (hasMerge) {
          _builder.append("const merge = [];");
          _builder.newLine();
        }
      }
      _builder.append("const n = ctx.getChildCount();");
      _builder.newLine();
      _builder.append("if (0<n) {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("for (let i = 0; i < n;++i) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("const it = ctx.getChild(i);");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (it instanceof RuleContext) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("switch (it.invokingState) {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      final HashSet<Integer> stateList = CollectionLiterals.<Integer>newHashSet();
      _builder.newLineIfNotEmpty();
      {
        for(final Element it_1 : elementList) {
          _builder.append("\t\t\t\t");
          final EObject atom = it_1.getBody();
          _builder.newLineIfNotEmpty();
          {
            if ((atom instanceof Atom)) {
              _builder.append("\t\t\t\t");
              final EObject ref = ((Atom)atom).getBody();
              _builder.newLineIfNotEmpty();
              {
                if ((ref instanceof RuleRef)) {
                  _builder.append("\t\t\t\t");
                  final Integer invokingState = this.getInvokingState(r);
                  _builder.newLineIfNotEmpty();
                  {
                    boolean _add = stateList.add(invokingState);
                    if (_add) {
                      _builder.append("\t\t\t\t");
                      _builder.append("case ");
                      _builder.append(invokingState, "\t\t\t\t");
                      _builder.append(": {");
                      _builder.newLineIfNotEmpty();
                      {
                        String _op = it_1.getOp();
                        boolean _equals_4 = Objects.equal(_op, "ADD");
                        if (_equals_4) {
                          _builder.append("\t\t\t\t");
                          _builder.append("\t");
                          _builder.append("const results = this.flatten(this.visit(it));");
                          _builder.newLine();
                          _builder.append("\t\t\t\t");
                          _builder.append("\t");
                          _builder.append("if(Array.isArray(results)){");
                          _builder.newLine();
                          _builder.append("\t\t\t\t");
                          _builder.append("\t");
                          _builder.append("\t");
                          _builder.append("for (const result of results)");
                          _builder.newLine();
                          _builder.append("\t\t\t\t");
                          _builder.append("\t");
                          _builder.append("\t\t");
                          _builder.append("add.push(result);");
                          _builder.newLine();
                          _builder.append("\t\t\t\t");
                          _builder.append("\t");
                          _builder.append("}");
                          _builder.newLine();
                          _builder.append("\t\t\t\t");
                          _builder.append("\t");
                          _builder.append("else");
                          _builder.newLine();
                          _builder.append("\t\t\t\t");
                          _builder.append("\t");
                          _builder.append("\t");
                          _builder.append("add.push(results);");
                          _builder.newLine();
                        }
                      }
                      {
                        String _op_1 = it_1.getOp();
                        boolean _notEquals_2 = (!Objects.equal(_op_1, "ADD"));
                        if (_notEquals_2) {
                          _builder.append("\t\t\t\t");
                          _builder.append("\t");
                          String _xifexpression_4 = null;
                          String _op_2 = it_1.getOp();
                          boolean _equals_5 = Objects.equal(_op_2, "MERGE");
                          if (_equals_5) {
                            _xifexpression_4 = it_1.getOp().toLowerCase();
                          } else {
                            String _xifexpression_5 = null;
                            String _op_3 = it_1.getOp();
                            boolean _equals_6 = Objects.equal(_op_3, "RETURN");
                            if (_equals_6) {
                              _xifexpression_5 = "ret";
                            } else {
                              _xifexpression_5 = it_1.getOp();
                            }
                            _xifexpression_4 = _xifexpression_5;
                          }
                          _builder.append(_xifexpression_4, "\t\t\t\t\t");
                          _builder.append(".push(this.visit(it));");
                          _builder.newLineIfNotEmpty();
                        }
                      }
                      _builder.append("\t\t\t\t");
                      _builder.append("}");
                      _builder.newLine();
                      _builder.append("\t\t\t\t");
                      _builder.append("break;");
                      _builder.newLine();
                    }
                  }
                }
              }
            }
          }
        }
      }
      _builder.append("\t\t\t\t");
      _builder.append("default: {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("none.push(this.visit(it));");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("break;");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("} else if (it instanceof TerminalNode) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("switch (it.symbol.type) {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      final HashSet<String> nameList = CollectionLiterals.<String>newHashSet();
      _builder.newLineIfNotEmpty();
      {
        for(final Element it_2 : elementList) {
          _builder.append("\t\t\t\t");
          final EObject atom_1 = it_2.getBody();
          _builder.newLineIfNotEmpty();
          {
            if ((atom_1 instanceof Atom)) {
              _builder.append("\t\t\t\t");
              final EObject ref_1 = ((Atom)atom_1).getBody();
              _builder.newLineIfNotEmpty();
              {
                if (((ref_1 instanceof Terminal) && nameList.add(this.getTerminalName(it_2)))) {
                  _builder.append("\t\t\t\t");
                  _builder.append("case ");
                  _builder.append(this._grammarName, "\t\t\t\t");
                  _builder.append("Parser.");
                  String _terminalName = this.getTerminalName(it_2);
                  _builder.append(_terminalName, "\t\t\t\t");
                  _builder.append(": {");
                  _builder.newLineIfNotEmpty();
                  _builder.append("\t\t\t\t");
                  _builder.append("\t");
                  String _xifexpression_6 = null;
                  if ((Objects.equal(it_2.getOp(), "MERGE") || Objects.equal(it_2.getOp(), "ADD"))) {
                    _xifexpression_6 = it_2.getOp().toLowerCase();
                  } else {
                    String _xifexpression_7 = null;
                    String _op_4 = it_2.getOp();
                    boolean _equals_7 = Objects.equal(_op_4, "RETURN");
                    if (_equals_7) {
                      _xifexpression_7 = "ret";
                    } else {
                      _xifexpression_7 = it_2.getOp();
                    }
                    _xifexpression_6 = _xifexpression_7;
                  }
                  _builder.append(_xifexpression_6, "\t\t\t\t\t");
                  _builder.append(".push(this.visit(it));");
                  _builder.newLineIfNotEmpty();
                  _builder.append("\t\t\t\t");
                  _builder.append("}");
                  _builder.newLine();
                  _builder.append("\t\t\t\t");
                  _builder.append("break;");
                  _builder.newLine();
                }
              }
            }
          }
        }
      }
      _builder.append("\t\t\t\t");
      _builder.append("default: {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("none.push(this.visit(it));");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("break;");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      {
        if (hasReturn) {
          _builder.append("if (!ret.isEmpty()) {");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("return ret;");
          _builder.newLine();
          _builder.append("}");
          _builder.newLine();
        }
      }
      _builder.append("const node = ");
      {
        UnicoenTypeDec _type = r.getType();
        boolean _tripleEquals = (_type == null);
        if (_tripleEquals) {
          _builder.append("map");
        }
      }
      {
        UnicoenTypeDec _type_1 = r.getType();
        boolean _tripleNotEquals = (_type_1 != null);
        if (_tripleNotEquals) {
          _builder.append("this.castTo");
          {
            if ((!hasMerge)) {
              _builder.append("List");
            }
          }
          _builder.append("(map, ");
          _builder.append(itemClassName);
          _builder.append(")");
        }
      }
      _builder.newLineIfNotEmpty();
      {
        if ((!hasMerge)) {
          _builder.append("return node;");
          _builder.newLine();
        }
      }
      {
        if (hasMerge) {
          _builder.append("const ret = [];");
          _builder.newLine();
          _builder.append("this.castToList(merge, ");
          _builder.append(itemClassName);
          _builder.append(").forEach( (it:any) => {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("it.merge(node);");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("ret.push(it);");
          _builder.newLine();
          _builder.append("});");
          _builder.newLine();
          _builder.append("return ret;");
          _builder.newLine();
        }
      }
      _xblockexpression = _builder;
    }
    return _xblockexpression;
  }
  
  public CharSequence makeStringMethodBody(final ParserRule r) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("const map = new Map<string, any>();");
    _builder.newLine();
    _builder.append("const none = [];");
    _builder.newLine();
    _builder.append("map.set(\"none\", none);");
    _builder.newLine();
    _builder.append("const n = node.getChildCount();");
    _builder.newLine();
    _builder.append("for (let i = 0; i < n;++i) {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("const it = node.getChild(i);");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("none.push(this.visit(it));");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.append("return map;");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence makeLiteralMethod(final ParserRule r) {
    StringConcatenation _builder = new StringConcatenation();
    String _camelCase = this.toCamelCase(r.getName());
    final String methodName = ("visit" + _camelCase);
    _builder.newLineIfNotEmpty();
    _builder.append("public ");
    _builder.append(methodName);
    _builder.append("(ctx:");
    _builder.append(this._grammarName);
    _builder.append("Parser.");
    String _camelCase_1 = this.toCamelCase(r.getName());
    _builder.append(_camelCase_1);
    _builder.append("Context) {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("const findFirst = (ctx) => {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const n = ctx.getChildCount();");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (let i = 0; i < n;++i) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("const it = ctx.getChild(i);\t");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if (it instanceof TerminalNodeImpl) {");
    _builder.newLine();
    {
      List<Element> _list = IteratorExtensions.<Element>toList(Iterators.<Element>filter(r.eAllContents(), Element.class));
      for(final Element it : _list) {
        {
          String _op = it.getOp();
          boolean _tripleNotEquals = (_op != null);
          if (_tripleNotEquals) {
            {
              String _op_1 = it.getOp();
              boolean _equals = Objects.equal(_op_1, "value");
              if (_equals) {
                _builder.append("\t\t\t\t");
                _builder.append("if (it.symbol.type == ");
                _builder.append(this._grammarName, "\t\t\t\t");
                _builder.append("Parser.");
                String _terminalName = this.getTerminalName(it);
                _builder.append(_terminalName, "\t\t\t\t");
                _builder.append(") {");
                _builder.newLineIfNotEmpty();
                _builder.append("\t\t\t\t");
                _builder.append("\t");
                _builder.append("return it;");
                _builder.newLine();
                _builder.append("\t\t\t\t");
                _builder.append("}");
                _builder.newLine();
              }
            }
          }
        }
      }
    }
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return undefined;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("};");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("const text = this.visit(findFirst(ctx)) as String;");
    _builder.newLine();
    {
      String _name = r.getType().getType().getName();
      boolean _equals_1 = Objects.equal(_name, "UniIntLiteral");
      if (_equals_1) {
        _builder.append("\t");
        _builder.append("return new UniIntLiteral(Number(text));");
        _builder.newLine();
      } else {
        String _name_1 = r.getType().getType().getName();
        boolean _equals_2 = Objects.equal(_name_1, "UniBoolLiteral");
        if (_equals_2) {
          _builder.append("\t");
          _builder.append("return new UniBoolLiteral(Boolean(text));");
          _builder.newLine();
        } else {
          String _name_2 = r.getType().getType().getName();
          boolean _equals_3 = Objects.equal(_name_2, "UniDoubleLiteral");
          if (_equals_3) {
            _builder.append("\t");
            _builder.append("return new UniDoubleLiteral(Number(text));");
            _builder.newLine();
          } else {
            String _name_3 = r.getType().getType().getName();
            boolean _equals_4 = Objects.equal(_name_3, "UniStringLiteral");
            if (_equals_4) {
              _builder.append("\t");
              _builder.append("return new UniStringLiteral(text.substring(1, text.length - 1));");
              _builder.newLine();
            } else {
              String _name_4 = r.getType().getType().getName();
              boolean _equals_5 = Objects.equal(_name_4, "UniCharacterLiteral");
              if (_equals_5) {
                _builder.append("\t");
                _builder.append("return new UniCharacterLiteral(text.substring(1, text.length - 1).charAt(0));");
                _builder.newLine();
              } else {
                _builder.append("\t");
                _builder.append("throw new RuntimeException(\"Unimplemented Method: ");
                _builder.append(methodName, "\t");
                _builder.append("\");");
                _builder.newLineIfNotEmpty();
              }
            }
          }
        }
      }
    }
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  public void die(final String message) {
    throw new RuntimeException(message);
  }
  
  public Integer getInvokingState(final ParserRule r) {
    return this._analyzer.getInvokingState(r);
  }
}
