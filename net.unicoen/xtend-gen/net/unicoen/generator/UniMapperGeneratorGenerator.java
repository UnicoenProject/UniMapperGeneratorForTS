/**
 * generated by Xtext 2.13.0
 */
package net.unicoen.generator;

import com.google.common.base.Objects;
import com.google.common.collect.Iterators;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.HashSet;
import java.util.List;
import java.util.function.Consumer;
import net.unicoen.generator.ANTLRGrammarGenerator;
import net.unicoen.uniMapperGenerator.Atom;
import net.unicoen.uniMapperGenerator.Element;
import net.unicoen.uniMapperGenerator.Grammar;
import net.unicoen.uniMapperGenerator.LexerRule;
import net.unicoen.uniMapperGenerator.ParserRule;
import net.unicoen.uniMapperGenerator.RuleRef;
import net.unicoen.uniMapperGenerator.Terminal;
import net.unicoen.uniMapperGenerator.TokenRef;
import net.unicoen.uniMapperGenerator.UnicoenTypeDec;
import net.unicoen.util.InvokingStateAnalyzer;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class UniMapperGeneratorGenerator extends AbstractGenerator {
  private String _grammarName;
  
  private InvokingStateAnalyzer _analyzer;
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    final ANTLRGrammarGenerator g4Generator = new ANTLRGrammarGenerator(fsa);
    final Procedure1<Grammar> _function = (Grammar it) -> {
      this._grammarName = this.toCamelCase(it.getName());
      final String parserCode = g4Generator.generate(this._grammarName, it);
      InvokingStateAnalyzer _invokingStateAnalyzer = new InvokingStateAnalyzer(parserCode, it);
      this._analyzer = _invokingStateAnalyzer;
      fsa.generateFile((this._grammarName + "Mapper.ts"), this.generateMapper(it));
    };
    IteratorExtensions.<Grammar>forEach(Iterators.<Grammar>filter(resource.getAllContents(), Grammar.class), _function);
  }
  
  public CharSequence generateImports(final Grammar g) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("import { ");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("ANTLRInputStream, ");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("CommonTokenStream, ");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("ParserRuleContext, ");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("RuleContext, ");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Token ");
    _builder.newLine();
    _builder.append("} from \'antlr4ts\';");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import { ParseTree } from \"antlr4ts/tree/ParseTree\";");
    _builder.newLine();
    _builder.append("import { RuleNode } from \"antlr4ts/tree/RuleNode\";");
    _builder.newLine();
    _builder.append("import { ErrorNode } from \"antlr4ts/tree/ErrorNode\";");
    _builder.newLine();
    _builder.append("import { TerminalNode } from \"antlr4ts/tree/TerminalNode\";");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import { «_grammarName»Lexer } from \'./«_grammarName»Lexer\';");
    _builder.newLine();
    _builder.append("import { «_grammarName»Parser } from \'./«_grammarName»Parser\';");
    _builder.newLine();
    _builder.append("import { «_grammarName»Visitor } from \'./«_grammarName»Visitor\';");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("import { ");
    _builder.newLine();
    _builder.append("«FOR r : g.rules.filter(ParserRule)»");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("«IF !(r.type !== null && r.type.type.name !== null && r.type.type.name.endsWith(\"Literal\"))");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("&& r.type !== null || r.eAllContents.filter(Element).findFirst[it.op !== null] !== null»\t\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("«r.name.toCamelCase»Context,");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("«ENDIF»");
    _builder.newLine();
    _builder.append("«ENDFOR»");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("} from \"./«_grammarName»Parser\";");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import { CodeLocation } from \'../../node_helper/CodeLocation\';");
    _builder.newLine();
    _builder.append("import { CodeRange } from \'../../node_helper/CodeRange\';");
    _builder.newLine();
    _builder.append("import { UniNode } from \'../../node/UniNode\';");
    _builder.newLine();
    _builder.append("import { UniParam } from \'../../node/UniParam\';");
    _builder.newLine();
    _builder.append("import { UniEnhancedFor } from \'../../node/UniEnhancedFor\';");
    _builder.newLine();
    _builder.append("import { UniExpr } from \'../../node/UniExpr\';");
    _builder.newLine();
    _builder.append("import { UniArray } from \'../../node/UniArray\';");
    _builder.newLine();
    _builder.append("import { UniNumberLiteral } from \'../../node/UniNumberLiteral\';");
    _builder.newLine();
    _builder.append("import { UniBinOp } from \'../../node/UniBinOp\';");
    _builder.newLine();
    _builder.append("import { UniBlock } from \'../../node/UniBlock\';");
    _builder.newLine();
    _builder.append("import { UniBoolLiteral } from \'../../node/UniBoolLiteral\';");
    _builder.newLine();
    _builder.append("import { UniBreak } from \'../../node/UniBreak\';");
    _builder.newLine();
    _builder.append("import { UniCharacterLiteral } from \'../../node/UniCharacterLiteral\';");
    _builder.newLine();
    _builder.append("import { UniCast } from \'../../node/UniCast\';");
    _builder.newLine();
    _builder.append("import { UniContinue } from \'../../node/UniContinue\';");
    _builder.newLine();
    _builder.append("import { UniClassDec } from \'../../node/UniClassDec\';");
    _builder.newLine();
    _builder.append("import { UniDecralation } from \'../../node/UniDecralation\';\t");
    _builder.newLine();
    _builder.append("import { UniDoubleLiteral } from \'../../node/UniDoubleLiteral\';");
    _builder.newLine();
    _builder.append("import { UniDoWhile } from \'../../node/UniDoWhile\';\t");
    _builder.newLine();
    _builder.append("import { UniEmptyStatement } from \'../../node/UniEmptyStatement\';");
    _builder.newLine();
    _builder.append("import { UniFunctionDec } from \'../../node/UniFunctionDec\';");
    _builder.newLine();
    _builder.append("import { UniFor } from \'../../node/UniFor\';");
    _builder.newLine();
    _builder.append("import { UniIdent } from \'../../node/UniIdent\';");
    _builder.newLine();
    _builder.append("import { UniIf } from \'../../node/UniIf\';");
    _builder.newLine();
    _builder.append("import { UniIntLiteral } from \'../../node/UniIntLiteral\';\t\t");
    _builder.newLine();
    _builder.append("import { UniMethodCall } from \'../../node/UniMethodCall\';");
    _builder.newLine();
    _builder.append("import { UniNew } from \'../../node/UniNew\';");
    _builder.newLine();
    _builder.append("import { UniNewArray } from \'../../node/UniNewArray\';");
    _builder.newLine();
    _builder.append("import { UniWhile } from \'../../node/UniWhile\';");
    _builder.newLine();
    _builder.append("import { UniUnaryOp } from \'../../node/UniUnaryOp\';");
    _builder.newLine();
    _builder.append("import { UniTernaryOp } from \'../../node/UniTernaryOp\';");
    _builder.newLine();
    _builder.append("import { UniStatement } from \'../../node/UniStatement\';");
    _builder.newLine();
    _builder.append("import { UniStringLiteral } from \'../../node/UniStringLiteral\';");
    _builder.newLine();
    _builder.append("import { UniReturn } from \'../../node/UniReturn\';");
    _builder.newLine();
    _builder.append("import { UniVariableDec } from \'../../node/UniVariableDec\';");
    _builder.newLine();
    _builder.append("import { UniVariableDef } from \'../../node/UniVariableDef\';");
    _builder.newLine();
    _builder.append("import { UniSwitchUnit } from \'../../node/UniSwitchUnit\';");
    _builder.newLine();
    _builder.append("import { UniSwitch } from \'../../node/UniSwitch\';");
    _builder.newLine();
    _builder.append("import { UniProgram } from \'../../node/UniProgram\';");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence generateMapper(final Grammar g) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("// tslint:disable");
    _builder.newLine();
    _builder.append("«g.generateImports»");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class Comment {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("constructor(readonly contents:string[], public parent:ParseTree){");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("export class «_grammarName»Mapper implements «_grammarName»Visitor<any> {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("private isDebugMode:boolean = false;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("private parser:«_grammarName»Parser;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("private\t_comments:Comment[] = [];");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("private _lastNode:UniNode;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("private _nextTokenIndex:number;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("private _stream:CommonTokenStream;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("setIsDebugMode(isDebugMode:boolean) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("this.isDebugMode = isDebugMode;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("getRawTree(code) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const chars = new ANTLRInputStream(code);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const lexer = new «_grammarName»Lexer(chars);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const tokens = new CommonTokenStream(lexer);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("this.parser = new «_grammarName»Parser(tokens);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const tree = this.parser.translationunit();");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return [tree, this.parser];");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("parse(code:string) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return this.parseCore(new ANTLRInputStream(code));");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("parseCore(chars:ANTLRInputStream) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const lexer = new «_grammarName»Lexer(chars);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const tokens = new CommonTokenStream(lexer);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("this.parser = new «_grammarName»Parser(tokens);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const tree = this.parser.«g.root.root.name»();");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("this._comments = [];");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("this._stream = tokens;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("this._lastNode = null;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("this._nextTokenIndex = 0;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("«IF g.rules.size > 0»");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const ret = new UniProgram(this.visit(tree));");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("ret.codeRange = ret.block.codeRange;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (this._lastNode !== null) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("const count = this._stream.getTokens().length - 1");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("for (var i = this._nextTokenIndex; i < count; i++) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("const hiddenToken = this._stream.getTokens()[i]; // Includes skipped tokens (maybe)");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("if (this._lastNode.comments === null) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("this._lastNode.comments = [];");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("this._lastNode.comments.push(hiddenToken.text);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return ret;");
    _builder.newLine();
    _builder.append("\t  ");
    _builder.append("«ENDIF»");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/*def parseFile(String path) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val inputStream = new FileInputStream(path)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("try {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("parseCore(new ANTLRInputStream(inputStream))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("} finally {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("inputStream.close");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def parseFile(String path, Function1<«_grammarName»Parser, ParseTree> parseAction) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("val inputStream = new FileInputStream(path)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("try {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("parseCore(new ANTLRInputStream(inputStream), parseAction)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("} finally {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("inputStream.close");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}*/");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public visitChildren(node:RuleNode) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const n = node.childCount;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const list:any[] = [];");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (let i = 0; i < n;++i) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("const c = node.getChild(i);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("const childResult = this.visit(c);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("list.push(childResult);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const flatten = this.flatten(list);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return flatten;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public visit(tree:ParseTree) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const result = (() => {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if (!this.isDebugMode) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("return tree.accept(this);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t \t\t");
    _builder.append("if (!(tree instanceof RuleContext)) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("return tree.accept(this);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("const ruleName = this.getRuleName(tree);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("console.log(\'*** visit Rule : \' + ruleName + \' ***\');");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("const result = tree.accept(this);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("console.log(\'returned: \' + result);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("return result;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("})();");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const node = (Array.isArray(result) && result.length == 1) ? result[0] : result;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (node instanceof UniNode) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if(tree instanceof ParserRuleContext) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("const start = tree.start;");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("const begin = new CodeLocation(start.charPositionInLine,start.line);");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("const stop = tree.stop;");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("const endPos = stop.charPositionInLine;");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("const length = 1 + stop.stopIndex - stop.startIndex;");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("const end = new CodeLocation(endPos + length, stop.line);");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("node.codeRange = new CodeRange(begin,end);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("let contents:string[]  = [];");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("for (let i = this._comments.length - 1; i >= 0 && this._comments[i].parent == tree; i--) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("for(const content of contents) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("this._comments[i].contents.push(content);");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("contents = this._comments[i].contents;");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("this._comments.splice(i, 1);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if (contents.length > 0) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("if (node.comments === null) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("node.comments = contents;");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("} else {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("node.comments = node.comments.concat(contents);");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("this._lastNode = node;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("} else {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("for (var i = this._comments.length - 1; i >= 0 && this._comments[i].parent == tree; i--) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("this._comments[i].parent = this._comments[i].parent.parent");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("this._lastNode = null");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return result;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("isNonEmptyNode(node:ParseTree):boolean {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (node instanceof ParserRuleContext) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("const n = node.childCount;");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if (n > 1) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("return true;");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("// n === 1 && node.children.exists[isNonEmptyNode]");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("return n === 1;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("} else {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("return true;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("visitErrorNode(node: ErrorNode): UniNode{");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return null;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}\t\t\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("getRuleName(node) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return this.parser.ruleNames[node.ruleIndex];");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public visitTerminal(node:TerminalNode) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (this.isDebugMode) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("console.log(\"visit TERMINAL : \" + node.text);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const token = node.symbol;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (token.type > 0) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("const count = token.tokenIndex;");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("const contents:string[] = [];");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("let i = this._nextTokenIndex;");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("for (; i < count; i++) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("const hiddenToken = this._stream.getTokens()[i]; // Includes skipped tokens (maybe)");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("if (this._lastNode !== null && this._stream.getTokens()[this._nextTokenIndex - 1].line == hiddenToken.line) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("if (this._lastNode.comments === null) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t");
    _builder.append("this._lastNode.comments = [];");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("this._lastNode.comments.push(hiddenToken.text);");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("} else {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("contents.push(hiddenToken.text);");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("const count2 = this._stream.getTokens().length - 1;");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("for (i = count + 1; i < count2 && this._stream.getTokens()[i].channel == Token.HIDDEN_CHANNEL &&");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("this._stream.getTokens()[count].line == this._stream.getTokens()[i].line; i++) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("contents.push(this._stream.getTokens()[i].text);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if (contents.length > 0) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("this._comments.push(new Comment(contents, node.parent));");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("this._nextTokenIndex = i;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return token.text;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("private flatten(obj:any) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (Array.isArray(obj)) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if (obj.length === 1) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("return this.flatten(obj[0]);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("const ret = [];");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("obj.forEach((it:any) => {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("ret.push(this.flatten(it));");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("});");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("return ret;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (obj instanceof Map) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if (obj.size === 1) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("for (const value of obj.values()) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("return this.flatten(value);");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("const ret = new Map<any, any>();");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("obj.forEach((value: any, key: any) => {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("ret.set(key, this.flatten(value));");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("});");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("return ret;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return obj;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public castToList<T extends Function|String>(obj:any, clazz:T):T[] {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const temp = this.flatten(obj);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const ret = [];");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (temp instanceof Map) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("const add = temp.has(\'add\');");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("temp.forEach((value: any, key: any) => {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("switch (key) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("case \'add\': {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("if (value instanceof Map) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t");
    _builder.append("ret.push(this.castTo<T>(value, clazz));");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("} else if (Array.isArray(value)) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t");
    _builder.append("value.forEach((it:any) => {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t\t");
    _builder.append("const t = this.castTo(it, clazz);");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t\t");
    _builder.append("if (t != null) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t\t\t");
    _builder.append("ret.push(t);");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t");
    _builder.append("});");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("} else {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t");
    _builder.append("ret.push(this.castToList(value, clazz));");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("} ");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("break;");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("default:");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("if (!add) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t");
    _builder.append("ret.push(this.castToList(value, clazz));");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("break;");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}\t");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("});");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("} else if (Array.isArray(temp)) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("temp.forEach((it:any) => {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("ret.push(this.castToList(it, clazz));");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("});");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("} else {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("ret.push(this.castTo(temp, clazz));");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return ret;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public castTo<T extends Function|String>(obj:any, clazz:any) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const temp = this.flatten(obj);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const instance = new clazz();");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const fields = instance.fields;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const fieldsName = [];");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (let it in instance) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("fieldsName.push(it);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (temp instanceof Map) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if (clazz === String) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("let builder = \'\';");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("const hasAdd = temp.has(\'add\');");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("temp.forEach((value: any, key: any) => {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("switch (key) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("case \'add\': {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t");
    _builder.append("builder += this.castTo<T>(value, clazz);");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("break;");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("default: {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t");
    _builder.append("if (!hasAdd) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t\t");
    _builder.append("builder += this.castTo<T>(value, clazz);");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("break;");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("});");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("return (builder.length > 0) ? builder : null;");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("temp.forEach((value: any, key: any) => {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("if (fieldsName.includes(key)) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("const field:Function = fields.get(key);");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("if (Array.isArray(instance[key])) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t");
    _builder.append("const list\t= this.flatten(this.castToList(value, field));");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t");
    _builder.append("if(!Array.isArray(list)) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t\t");
    _builder.append("instance[key] = [list];");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t");
    _builder.append("} else {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t\t");
    _builder.append("instance[key] = list;");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("} else if (value.length == 0");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t");
    _builder.append("&& (field == UniExpr || field == UniStatement )){");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t");
    _builder.append("instance[key] = null;");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("} else {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t");
    _builder.append("instance[key] = this.castTo(value, field);");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("});");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("return instance;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (Array.isArray(temp)) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if (clazz === String) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("let builder = \'\';");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("temp.forEach((it:any) => {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("builder += (this.castTo(it, clazz));");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("});");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("return (builder.length > 0) ? builder : null;");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("const first = temp.find((it) => {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("return it instanceof clazz;");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("});");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if (first === null) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("try {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("return instance;");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("} catch (e) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("return null;");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("} else {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("return this.castTo<T>(first,clazz);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if(temp != null) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("return temp as T;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return instance;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("«FOR r : g.rules.filter(ParserRule)»");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("«IF r.type !== null && r.type.type.name !== null && r.type.type.name.endsWith(\"Literal\")»");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("«r.makeLiteralMethod»");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("«ELSEIF r.type !== null || r.eAllContents.filter(Element).findFirst[it.op !== null] !== null»");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("«r.makeVisitMethod»");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("«ENDIF»");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("«ENDFOR»");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  public String toCamelCase(final String str) {
    char _upperCase = Character.toUpperCase(str.charAt(0));
    String _substring = str.substring(1);
    return (Character.valueOf(_upperCase) + _substring);
  }
  
  public CharSequence makeVisitMethod(final ParserRule r) {
    CharSequence _xblockexpression = null;
    {
      final String ruleName = this.toCamelCase(r.getName());
      String _xifexpression = null;
      UnicoenTypeDec _type = r.getType();
      boolean _tripleNotEquals = (_type != null);
      if (_tripleNotEquals) {
        _xifexpression = r.getType().getType().getName();
      } else {
        _xifexpression = new String();
      }
      final String typeName = _xifexpression;
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("public visit«ruleName»(ctx:«ruleName»Context) {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("«IF typeName==\"List\"»");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("«r.makeListMethodBody(r.type.type.typevalue)»");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("«ELSE»");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("«r.makeMethodBody»");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("«ENDIF»");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _xblockexpression = _builder;
    }
    return _xblockexpression;
  }
  
  public CharSequence makeMethodBody(final ParserRule r) {
    CharSequence _xblockexpression = null;
    {
      final HashSet<String> annotationList = CollectionLiterals.<String>newHashSet();
      final Function1<Element, Boolean> _function = (Element it) -> {
        String _op = it.getOp();
        return Boolean.valueOf((_op != null));
      };
      final List<Element> elementList = IteratorExtensions.<Element>toList(IteratorExtensions.<Element>filter(Iterators.<Element>filter(r.eAllContents(), Element.class), _function));
      final Function1<Element, Boolean> _function_1 = (Element it) -> {
        String _op = it.getOp();
        return Boolean.valueOf(Objects.equal(_op, "MERGE"));
      };
      Element _findFirst = IterableExtensions.<Element>findFirst(elementList, _function_1);
      final boolean hasMerge = (_findFirst != null);
      final Function1<Element, Boolean> _function_2 = (Element it) -> {
        String _op = it.getOp();
        return Boolean.valueOf(Objects.equal(_op, "RETURN"));
      };
      Element _findFirst_1 = IterableExtensions.<Element>findFirst(elementList, _function_2);
      final boolean hasReturn = (_findFirst_1 != null);
      final Consumer<Element> _function_3 = (Element it) -> {
        String _op = it.getOp();
        annotationList.add(_op);
      };
      elementList.forEach(_function_3);
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("const map = new Map<string,any>();");
      _builder.newLine();
      _builder.append("const none = [];");
      _builder.newLine();
      _builder.append("map.set(\"none\", none);");
      _builder.newLine();
      _builder.append("«FOR it : annotationList»«IF it != \"MERGE\"»");
      _builder.newLine();
      _builder.append("const «if (it == \"ADD\") it.toLowerCase else if (it == \"RETURN\") \"ret\" else it» = [];");
      _builder.newLine();
      _builder.append("«IF it != \"RETURN\"»");
      _builder.newLine();
      _builder.append("map.set(\"«if (it == \"ADD\") it.toLowerCase else it»\", «if (it == \"ADD\") it.toLowerCase else it»);");
      _builder.newLine();
      _builder.append("«ENDIF»«ENDIF»«ENDFOR»");
      _builder.newLine();
      _builder.append("«IF hasMerge»");
      _builder.newLine();
      _builder.append("const merge = [];");
      _builder.newLine();
      _builder.append("«ENDIF»");
      _builder.newLine();
      _builder.append("const n = ctx.childCount;");
      _builder.newLine();
      _builder.append("for (let i = 0; i < n;++i) {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("const it = ctx.getChild(i);\t");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("if (it instanceof RuleContext) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("switch (it.invokingState) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("«val stateList = newHashSet»");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("«FOR it : elementList»");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("«val atom = it.body»");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("«IF atom instanceof Atom»");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("«val ref = atom.body»");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("«IF ref instanceof RuleRef»");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("«val invokingState = r.getInvokingState»");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("«IF stateList.add(invokingState)»");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t");
      _builder.append("case «invokingState»: {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t");
      _builder.append("«if (it.op == \"MERGE\" || it.op == \"ADD\") it.op.toLowerCase ");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t");
      _builder.append("else if (it.op == \"RETURN\") \"ret\" ");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t");
      _builder.append("else it.op».push(«IF r.type !== null && r.type.type.dir !== null»this.flatten(«ENDIF»this.visit(it)«IF r.type !== null && r.type.type.dir !== null»)«ENDIF»);");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t");
      _builder.append("break;");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("«ENDIF»");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("«ENDIF»");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("«ENDIF»");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("«ENDFOR»");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("default: {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("none.push(this.visit(it));");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("break;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("} else if (it instanceof TerminalNode) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("switch (it.symbol.type) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("«val nameList = newHashSet»");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("«FOR it : elementList»");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("«val atom = it.body»");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("«IF atom instanceof Atom»");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("«val ref = atom.body»");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("«IF ref instanceof Terminal && nameList.add(it.terminalName)»");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("case «_grammarName»Parser.«it.terminalName»: {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t");
      _builder.append("«if (it.op == \"MERGE\" || it.op == \"ADD\") it.op.toLowerCase else if (it.op == \"RETURN\") \"ret\" else it.op».push(this.flatten(this.visit(it)));");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("break;");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("«ENDIF»");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("«ENDIF»");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("«ENDFOR»");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("default: {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("none.push(this.visit(it));");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("break;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.append("«IF hasReturn»");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("if (!ret.isEmpty()) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return ret;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("«ENDIF»");
      _builder.newLine();
      _builder.append("«IF r.type !== null»");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("«IF r.type.type.name !== null»");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("«IF hasMerge»");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("let node = this.castTo(map, «r.type.type.name»);");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if(typeof node === \'object\' && \'merge\' in node){");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("merge.forEach((it:any) => { node.merge(this.castTo(it, «r.type.type.name»));});");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("} else {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("node = new «r.type.type.name»();");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("merge.forEach((it:any) => { node.merge(this.castTo(it, «r.type.type.name»));});");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("«ELSE»");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("const node = this.castTo(map, «r.type.type.name»);");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("«ENDIF»");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return node;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("«ELSE»");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("«IF r.type.type.dir == \'>\'»");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("add.reverse();");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("«ENDIF»");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("const node = add[0] as UniExpr;");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("for (Object obj : add) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("switch (obj) {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("«FOR field:r.type.type.fieldvalue»");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("«field.name.get(0)»: {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("obj.«field.name.get(1)» = node");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("node = obj");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("«ENDFOR»");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return node;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("«ENDIF»");
      _builder.newLine();
      _builder.append("«ELSE»");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("«IF hasMerge»");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("merge.forEach [");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("if (it instanceof Map<?, ?>) {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("it.forEach [ k, v |");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("if (map.containsKey(k)) {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("map.get(k) += v");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("} else {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("map.put(k, v as ArrayList<Object>)");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("]");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("«ENDIF»");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("return map;");
      _builder.newLine();
      _builder.append("«ENDIF»");
      _builder.newLine();
      _xblockexpression = _builder;
    }
    return _xblockexpression;
  }
  
  public String getReferenceReturnType(final Element r) {
    String _xblockexpression = null;
    {
      EObject _body = r.getBody();
      final EObject ref = ((Atom) _body).getBody();
      String _xifexpression = null;
      if ((ref instanceof RuleRef)) {
        String _xifexpression_1 = null;
        UnicoenTypeDec _type = ((RuleRef)ref).getReference().getType();
        boolean _tripleNotEquals = (_type != null);
        if (_tripleNotEquals) {
          _xifexpression_1 = ((RuleRef)ref).getReference().getType().getType().getName();
        }
        _xifexpression = _xifexpression_1;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  public String getTerminalName(final Element r) {
    String _xblockexpression = null;
    {
      EObject _body = r.getBody();
      final EObject ref = ((Atom) _body).getBody();
      String _xifexpression = null;
      if ((ref instanceof Terminal)) {
        TokenRef _reference = ((Terminal)ref).getReference();
        _xifexpression = ((LexerRule) _reference).getName();
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  public String getTypeName(final Type type) {
    boolean _matched = false;
    if (type instanceof Class) {
      _matched=true;
      return ((Class<?>)type).getName();
    }
    if (!_matched) {
      if (type instanceof ParameterizedType) {
        _matched=true;
        final StringBuilder sb = new StringBuilder();
        sb.append(((ParameterizedType)type).getTypeName()).append("<");
        boolean isFirst = true;
        Type[] _actualTypeArguments = ((ParameterizedType)type).getActualTypeArguments();
        for (final Type arg : _actualTypeArguments) {
          {
            if ((!isFirst)) {
              sb.append(",");
            }
            sb.append(arg.getTypeName());
          }
        }
        sb.append(">");
        return sb.toString();
      }
    }
    String _string = type.toString();
    String _plus = ("Unknown type:" + _string);
    this.die(_plus);
    return null;
  }
  
  public CharSequence makeListMethodBody(final ParserRule r, final String itemClassName) {
    CharSequence _xblockexpression = null;
    {
      final HashSet<String> annotationList = CollectionLiterals.<String>newHashSet();
      final Function1<Element, Boolean> _function = (Element it) -> {
        String _op = it.getOp();
        return Boolean.valueOf((_op != null));
      };
      final List<Element> elementList = IteratorExtensions.<Element>toList(IteratorExtensions.<Element>filter(Iterators.<Element>filter(r.eAllContents(), Element.class), _function));
      final Function1<Element, Boolean> _function_1 = (Element it) -> {
        String _op = it.getOp();
        return Boolean.valueOf(Objects.equal(_op, "MERGE"));
      };
      Element _findFirst = IterableExtensions.<Element>findFirst(elementList, _function_1);
      final boolean hasMerge = (_findFirst != null);
      final Function1<Element, Boolean> _function_2 = (Element it) -> {
        String _op = it.getOp();
        return Boolean.valueOf(Objects.equal(_op, "RETURN"));
      };
      Element _findFirst_1 = IterableExtensions.<Element>findFirst(elementList, _function_2);
      final boolean hasReturn = (_findFirst_1 != null);
      final Consumer<Element> _function_3 = (Element it) -> {
        String _op = it.getOp();
        annotationList.add(_op);
      };
      elementList.forEach(_function_3);
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("const map = new Map<string,any>();");
      _builder.newLine();
      _builder.append("const none = [];");
      _builder.newLine();
      _builder.append("map.set(\"none\", none);");
      _builder.newLine();
      _builder.append("«FOR it : annotationList»«IF it != \"MERGE\"»");
      _builder.newLine();
      _builder.append("const «if (it == \"ADD\") it.toLowerCase else if (it == \"RETURN\") \"ret\" else it» = [];");
      _builder.newLine();
      _builder.append("«IF it != \"RETURN\"»");
      _builder.newLine();
      _builder.append("map.set(\"«if (it == \"ADD\") it.toLowerCase else it»\", «if (it == \"ADD\") it.toLowerCase else it»);");
      _builder.newLine();
      _builder.append("«ENDIF»«ENDIF»«ENDFOR»");
      _builder.newLine();
      _builder.append("«IF hasMerge»");
      _builder.newLine();
      _builder.append("const merge = [];");
      _builder.newLine();
      _builder.append("«ENDIF»");
      _builder.newLine();
      _builder.append("const n = ctx.childCount;");
      _builder.newLine();
      _builder.append("if (0<n) {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("for (let i = 0; i < n;++i) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("const it = ctx.getChild(i);");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (it instanceof RuleContext) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("switch (it.invokingState) {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("«val stateList = newHashSet»");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("«FOR it : elementList»");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("«val atom = it.body»");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("«IF atom instanceof Atom»");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("«val ref = atom.body»");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("«IF ref instanceof RuleRef»");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t");
      _builder.append("«val invokingState = r.getInvokingState»");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t");
      _builder.append("«IF stateList.add(invokingState)»");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t");
      _builder.append("case «invokingState»: {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t\t");
      _builder.append("«IF (it.op == \"ADD\")»");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t\t\t");
      _builder.append("const results = this.flatten(this.visit(it));");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t\t\t");
      _builder.append("if(Array.isArray(results)){");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t\t\t\t");
      _builder.append("for (const result of results)");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t\t\t\t\t");
      _builder.append("add.push(result);");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t\t\t");
      _builder.append("else");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t\t\t\t");
      _builder.append("add.push(results);");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t\t");
      _builder.append("«ENDIF»");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t\t");
      _builder.append("«IF it.op != \"ADD\"»");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t\t\t");
      _builder.append("«if (it.op == \"MERGE\") it.op.toLowerCase ");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t\t\t\t");
      _builder.append("else if (it.op == \"RETURN\") \"ret\" ");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t\t\t\t");
      _builder.append("else it.op».push(this.visit(it));");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t\t");
      _builder.append("«ENDIF»\t");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t");
      _builder.append("break;");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t");
      _builder.append("«ENDIF»");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("«ENDIF»");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("«ENDIF»");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("«ENDFOR»");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("default: {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("none.push(this.visit(it));");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("break;");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("} else if (it instanceof TerminalNode) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("switch (it.symbol.type) {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("«val nameList = newHashSet»");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("«FOR it : elementList»");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("«val atom = it.body»");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("«IF atom instanceof Atom»");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("«val ref = atom.body»");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("«IF ref instanceof Terminal && nameList.add(it.terminalName)»");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t");
      _builder.append("case «_grammarName»Parser.«it.terminalName»: {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t");
      _builder.append("«if (it.op == \"MERGE\" || it.op == \"ADD\") it.op.toLowerCase else if (it.op == \"RETURN\") \"ret\" else it.op».push(this.visit(it));");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t");
      _builder.append("break;");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("«ENDIF»");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("«ENDIF»");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("«ENDFOR»");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("default: {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("none.push(this.visit(it));");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("break;");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.append("«IF hasReturn»");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("if (!ret.isEmpty()) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return ret;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("«ENDIF»");
      _builder.newLine();
      _builder.append("const node = «IF r.type === null»map«ENDIF»«IF r.type !== null»this.castTo«IF !hasMerge»List«ENDIF»(map, «itemClassName»)«ENDIF»");
      _builder.newLine();
      _builder.append("«IF !hasMerge»");
      _builder.newLine();
      _builder.append("return node;");
      _builder.newLine();
      _builder.append("«ENDIF»");
      _builder.newLine();
      _builder.append("«IF hasMerge»");
      _builder.newLine();
      _builder.append("const ret = [];");
      _builder.newLine();
      _builder.append("this.castToList(merge, «itemClassName»).forEach( (it:any) => {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("it.merge(node);");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("ret.push(it);");
      _builder.newLine();
      _builder.append("});");
      _builder.newLine();
      _builder.append("return ret;");
      _builder.newLine();
      _builder.append("«ENDIF»");
      _builder.newLine();
      _xblockexpression = _builder;
    }
    return _xblockexpression;
  }
  
  public CharSequence makeStringMethodBody(final ParserRule r) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("const map = new Map<string, any>();");
    _builder.newLine();
    _builder.append("const none = [];");
    _builder.newLine();
    _builder.append("map.set(\"none\", none);");
    _builder.newLine();
    _builder.append("const n = node.childCount;");
    _builder.newLine();
    _builder.append("for (let i = 0; i < n;++i) {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("const it = node.getChild(i);");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("none.push(this.visit(it));");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.append("return map;");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence makeLiteralMethod(final ParserRule r) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("«val methodName = \"visit\" + r.name.toCamelCase»");
    _builder.newLine();
    _builder.append("public «methodName»(ctx:«r.name.toCamelCase»Context) {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("const findFirst = (ctx) => {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("const n = ctx.childCount;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (let i = 0; i < n;++i) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("const it = ctx.getChild(i);\t");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if (it instanceof TerminalNode) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("«FOR it : r.eAllContents.filter(Element).toList»");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("«IF it.op !== null»");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t");
    _builder.append("«IF it.op == \"value\"»");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t\t");
    _builder.append("if (it.symbol.type == «_grammarName»Parser.«it.terminalName») {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t\t\t");
    _builder.append("return it;");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t");
    _builder.append("«ENDIF»");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("«ENDIF»");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("«ENDFOR»");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return undefined;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("};");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("const text = this.visit(findFirst(ctx)) as String;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("«IF r.type.type.name == \"UniIntLiteral\"»");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return new UniIntLiteral(Number(text));");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("«ELSEIF r.type.type.name == \"UniBoolLiteral\"»");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return new UniBoolLiteral(Boolean(text));");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("«ELSEIF r.type.type.name == \"UniDoubleLiteral\"»");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return new UniDoubleLiteral(Number(text));");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("«ELSEIF r.type.type.name == \"UniStringLiteral\"»");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return new UniStringLiteral(text.substring(1, text.length - 1));");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("«ELSEIF r.type.type.name == \"UniCharacterLiteral\"»");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return new UniCharacterLiteral(text.substring(1, text.length - 1));");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("«ELSE»");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("throw new RuntimeException(\"Unimplemented Method: «methodName»\");");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("«ENDIF»");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  public void die(final String message) {
    throw new RuntimeException(message);
  }
  
  public Integer getInvokingState(final ParserRule r) {
    return this._analyzer.getInvokingState(r);
  }
}
