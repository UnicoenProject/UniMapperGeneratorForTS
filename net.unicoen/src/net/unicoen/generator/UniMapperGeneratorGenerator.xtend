/*
 * generated by Xtext 2.13.0
 */
package net.unicoen.generator

import java.lang.reflect.Type
import java.lang.reflect.ParameterizedType
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import net.unicoen.uniMapperGenerator.Atom
import net.unicoen.uniMapperGenerator.Element
import net.unicoen.uniMapperGenerator.Grammar
import net.unicoen.uniMapperGenerator.LexerRule
import net.unicoen.uniMapperGenerator.ParserRule
import net.unicoen.uniMapperGenerator.RuleRef
import net.unicoen.uniMapperGenerator.Terminal
import net.unicoen.util.InvokingStateAnalyzer

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class UniMapperGeneratorGenerator extends AbstractGenerator {
	private String _grammarName
	private InvokingStateAnalyzer _analyzer
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val g4Generator = new ANTLRGrammarGenerator(fsa)
		resource.allContents.filter(Grammar).forEach [
			_grammarName = it.name.toCamelCase
			val parserCode = g4Generator.generate(_grammarName, it)
			_analyzer = new InvokingStateAnalyzer(parserCode, it)
			fsa.generateFile(_grammarName + "Mapper.ts", it.generateMapper)
		]
	}
	
	def generateImports(Grammar g) '''
		import { 
			ANTLRInputStream, 
			CommonTokenStream, 
			ParserRuleContext, 
			RuleContext, 
			Token 
		} from 'antlr4ts';
		
		import { ParseTree } from "antlr4ts/tree/ParseTree";
		import { RuleNode } from "antlr4ts/tree/RuleNode";
		import { ErrorNode } from "antlr4ts/tree/ErrorNode";
		import { TerminalNode } from "antlr4ts/tree/TerminalNode";
		
		import { «_grammarName»Lexer } from './«_grammarName»Lexer';
		import { «_grammarName»Parser } from './«_grammarName»Parser';
		import { «_grammarName»Visitor } from './«_grammarName»Visitor';
				
		import { 
		«FOR r : g.rules.filter(ParserRule)»
			«IF !(r.type !== null && r.type.type.name !== null && r.type.type.name.endsWith("Literal"))
			&& r.type !== null || r.eAllContents.filter(Element).findFirst[it.op !== null] !== null»			
				«r.name.toCamelCase»Context,
			«ENDIF»
		«ENDFOR»
			} from "./«_grammarName»Parser";
		
		import { CodeLocation } from '../../node_helper/CodeLocation';
		import { CodeRange } from '../../node_helper/CodeRange';
		import { UniNode } from '../../node/UniNode';
		import { UniParam } from '../../node/UniParam';
		import { UniEnhancedFor } from '../../node/UniEnhancedFor';
		import { UniExpr } from '../../node/UniExpr';
		import { UniArray } from '../../node/UniArray';
		import { UniNumberLiteral } from '../../node/UniNumberLiteral';
		import { UniBinOp } from '../../node/UniBinOp';
		import { UniBlock } from '../../node/UniBlock';
		import { UniBoolLiteral } from '../../node/UniBoolLiteral';
		import { UniBreak } from '../../node/UniBreak';
		import { UniCharacterLiteral } from '../../node/UniCharacterLiteral';
		import { UniCast } from '../../node/UniCast';
		import { UniContinue } from '../../node/UniContinue';
		import { UniClassDec } from '../../node/UniClassDec';
		import { UniDecralation } from '../../node/UniDecralation';	
		import { UniDoubleLiteral } from '../../node/UniDoubleLiteral';
		import { UniDoWhile } from '../../node/UniDoWhile';	
		import { UniEmptyStatement } from '../../node/UniEmptyStatement';
		import { UniFunctionDec } from '../../node/UniFunctionDec';
		import { UniFor } from '../../node/UniFor';
		import { UniIdent } from '../../node/UniIdent';
		import { UniIf } from '../../node/UniIf';
		import { UniImportDec } from '../../node/UniImportDec';
		import { UniIntLiteral } from '../../node/UniIntLiteral';		
		import { UniMethodCall } from '../../node/UniMethodCall';
		import { UniNew } from '../../node/UniNew';
		import { UniNewArray } from '../../node/UniNewArray';
		import { UniNoneLiteral } from '../../node/UniNoneLiteral';
		import { UniWhile } from '../../node/UniWhile';
		import { UniUnaryOp } from '../../node/UniUnaryOp';
		import { UniTernaryOp } from '../../node/UniTernaryOp';
		import { UniStatement } from '../../node/UniStatement';
		import { UniStringLiteral } from '../../node/UniStringLiteral';
		import { UniReturn } from '../../node/UniReturn';
		import { UniVariableDec } from '../../node/UniVariableDec';
		import { UniVariableDef } from '../../node/UniVariableDef';
		import { UniSwitchUnit } from '../../node/UniSwitchUnit';
		import { UniSwitch } from '../../node/UniSwitch';
		import { SyntaxErrorListener } from '../mapper/SyntaxErrorListener';
		import { SyntaxErrorData } from '../mapper/SyntaxErrorData';
		import { NodeComment } from '../mapper/NodeComment';
		import { Mapper } from '../mapper/Mapper';
		
		import '../../node_helper/Extension';
		import { RuntimeException } from '../Engine/RuntimeException';
	'''

	def generateMapper(Grammar g) '''
		// tslint:disable
		«g.generateImports»

		export class «_grammarName»Mapper extends Mapper implements «_grammarName»Visitor<any> {
		
			preProcess(text: string): string {
				return text;
			}
			
			parseToANTLRTree(code):ParserRuleContext {
				const preProcessedCode = this.preProcess(code);
				const chars = new ANTLRInputStream(preProcessedCode);
				const lexer = new «_grammarName»Lexer(chars);
				const tokens = new CommonTokenStream(lexer);
				const parser = new «_grammarName»Parser(tokens);
				parser.addErrorListener(new SyntaxErrorListener<any>());
				const tree = parser.«g.root.root.name»();
				this.parser = parser;
				return tree;
			}

			«FOR r : g.rules.filter(ParserRule)»
				«IF r.type !== null && r.type.type.name !== null && r.type.type.name.endsWith("Literal")»
					«r.makeLiteralMethod»

				«ELSEIF r.type !== null || r.eAllContents.filter(Element).findFirst[it.op !== null] !== null»
					«r.makeVisitMethod»

				«ENDIF»
			«ENDFOR»
		}
	'''

	def toCamelCase(String str) {
		Character.toUpperCase(str.charAt(0)) + str.substring(1)
	}

	def makeVisitMethod(ParserRule r) {
		val ruleName = r.name.toCamelCase
		val typeName = if (r.type !== null) {
			r.type.type.name
		} else {
			new String
		}
		'''
			public visit«ruleName»(ctx:«ruleName»Context) {
				«IF typeName=="List"»
					«r.makeListMethodBody(r.type.type.typevalue)»
				«ELSE»
					«r.makeMethodBody»
				«ENDIF»
			}
		'''
	}

	def makeMethodBody(ParserRule r) {
		val annotationList = newHashSet
		val elementList = r.eAllContents.filter(Element).filter[it.op !== null].toList
		val hasMerge = elementList.findFirst[it.op == "MERGE"] !== null
		val hasReturn = elementList.findFirst[it.op == "RETURN"] !== null
		elementList.forEach[
			annotationList += it.op
		]
	'''
		const map = new Map<string,any>();
		const none = [];
		map.set("none", none);
		«FOR it : annotationList»«IF it != "MERGE"»
		const «if (it == "ADD") it.toLowerCase else if (it == "RETURN") "ret" else it» = [];
		«IF it != "RETURN"»
		map.set("«if (it == "ADD") it.toLowerCase else it»", «if (it == "ADD") it.toLowerCase else it»);
		«ENDIF»«ENDIF»«ENDFOR»
		«IF hasMerge»
		const merge = [];
		«ENDIF»
		const n = ctx.childCount;
		for (let i = 0; i < n;++i) {
			const it = ctx.getChild(i);	
			if (it instanceof RuleContext) {
				switch (it.invokingState) {
					«val stateList = newHashSet»
					«FOR it : elementList»
						«val atom = it.body»
						«IF atom instanceof Atom»
							«val ref = atom.body»
							«IF ref instanceof RuleRef»
								«val invokingState = r.getInvokingState»
								«IF stateList.add(invokingState)»
									case «invokingState»: {
										«if (it.op == "MERGE" || it.op == "ADD") it.op.toLowerCase 
										else if (it.op == "RETURN") "ret" 
										else it.op».push(«IF r.type !== null && r.type.type.dir !== null»this.flatten(«ENDIF»this.visit(it)«IF r.type !== null && r.type.type.dir !== null»)«ENDIF»);
									}
									break;
								«ENDIF»
							«ENDIF»
						«ENDIF»
					«ENDFOR»
					default: {
						none.push(this.visit(it));
					}
					break;
				}
			} else if (it instanceof TerminalNode) {
				switch (it.symbol.type) {
					«val nameList = newHashSet»
					«FOR it : elementList»
						«val atom = it.body»
						«IF atom instanceof Atom»
							«val ref = atom.body»
							«IF ref instanceof Terminal && nameList.add(it.terminalName)»
								case «_grammarName»Parser.«it.terminalName»: {
									«if (it.op == "MERGE" || it.op == "ADD") it.op.toLowerCase else if (it.op == "RETURN") "ret" else it.op».push(this.flatten(this.visit(it)));
								}
								break;
							«ENDIF»
						«ENDIF»
					«ENDFOR»
					default: {
						none.push(this.visit(it));
					}
					break;
				}
			}
		}
		«IF hasReturn»
			if (!ret.isEmpty()) {
				return ret;
			}
		«ENDIF»
		«IF r.type !== null»
			«IF r.type.type.name !== null»
				«IF hasMerge»
				let node = this.castTo(map, «r.type.type.name»);
				if(typeof node === 'object' && 'merge' in node){
					merge.forEach((it:any) => { node.merge(this.castTo(it, «r.type.type.name»));});
				} else {
					node = new «r.type.type.name»();
					merge.forEach((it:any) => { node.merge(this.castTo(it, «r.type.type.name»));});
				}
				«ELSE»
				const node = this.castTo(map, «r.type.type.name»);
				«ENDIF»
				return node;
			«ELSE»
				«IF r.type.type.dir == '>'»
					add.reverse();
				«ENDIF»
				const node = add[0] as UniExpr;
				for (Object obj : add) {
					switch (obj) {
						«FOR field:r.type.type.fieldvalue»
						«field.name.get(0)»: {
							obj.«field.name.get(1)» = node
							node = obj
						}
						«ENDFOR»
					}
				}
				return node;
			«ENDIF»
		«ELSE»
			«IF hasMerge»
				merge.forEach [
					if (it instanceof Map<?, ?>) {
						it.forEach [ k, v |
							if (map.containsKey(k)) {
								map.get(k) += v
							} else {
								map.put(k, v as ArrayList<Object>)
							}
						]
					}
				]
			«ENDIF»
			return map;
		«ENDIF»
	'''}

	def getReferenceReturnType(Element r) {
		val ref = (r.body as Atom).body
		if (ref instanceof RuleRef) {
			if (ref.reference.type !== null) {
				ref.reference.type.type.name
			}
		}
	}

	def getTerminalName(Element r) {
		val ref = (r.body as Atom).body
		if (ref instanceof Terminal) {
			(ref.reference as LexerRule).name
		}
	}

	def getTypeName(Type type) {
		switch type {
			Class<?>:
				return type.name
			ParameterizedType: {
				val sb = new StringBuilder
				sb.append(type.typeName).append('<')
				var isFirst = true
				for (Type arg : type.actualTypeArguments) {
					if (!isFirst) {
						sb.append(',')
					}
					sb.append(arg.typeName)
				}
				sb.append('>')
				return sb.toString
			}
			default:
				die("Unknown type:" + type.toString)
		}
	}

	def makeListMethodBody(ParserRule r, String itemClassName) {
		val annotationList = newHashSet
		val elementList = r.eAllContents.filter(Element).filter[it.op !== null].toList
		val hasMerge = elementList.findFirst[ it.op == "MERGE" ] !== null
		val hasReturn = elementList.findFirst[ it.op == "RETURN" ] !== null
		elementList.forEach[
			annotationList += it.op
		]
		
	'''
		const map = new Map<string,any>();
		const none = [];
		map.set("none", none);
		«FOR it : annotationList»«IF it != "MERGE"»
		const «if (it == "ADD") it.toLowerCase else if (it == "RETURN") "ret" else it» = [];
		«IF it != "RETURN"»
		map.set("«if (it == "ADD") it.toLowerCase else it»", «if (it == "ADD") it.toLowerCase else it»);
		«ENDIF»«ENDIF»«ENDFOR»
		«IF hasMerge»
		const merge = [];
		«ENDIF»
		const n = ctx.childCount;
		if (0<n) {
			for (let i = 0; i < n;++i) {
				const it = ctx.getChild(i);
				if (it instanceof RuleContext) {
					switch (it.invokingState) {
						«val stateList = newHashSet»
						«FOR it : elementList»
							«val atom = it.body»
							«IF atom instanceof Atom»
								«val ref = atom.body»
								«IF ref instanceof RuleRef»
									«val invokingState = r.getInvokingState»
									«IF stateList.add(invokingState)»
										case «invokingState»: {
											«IF (it.op == "ADD")»
												const results = this.flatten(this.visit(it));
												if(Array.isArray(results)){
													for (const result of results)
														add.push(result);
												}
												else
													add.push(results);
											«ENDIF»
											«IF it.op != "ADD"»
												«if (it.op == "MERGE") it.op.toLowerCase 
													else if (it.op == "RETURN") "ret" 
													else it.op».push(this.visit(it));
											«ENDIF»	
										}
										break;
									«ENDIF»
								«ENDIF»
							«ENDIF»
						«ENDFOR»
						default: {
							none.push(this.visit(it));
						}
						break;
					}
				} else if (it instanceof TerminalNode) {
					switch (it.symbol.type) {
						«val nameList = newHashSet»
						«FOR it : elementList»
							«val atom = it.body»
							«IF atom instanceof Atom»
								«val ref = atom.body»
								«IF ref instanceof Terminal && nameList.add(it.terminalName)»
									case «_grammarName»Parser.«it.terminalName»: {
										«if (it.op == "MERGE" || it.op == "ADD") it.op.toLowerCase else if (it.op == "RETURN") "ret" else it.op».push(this.visit(it));
									}
									break;
								«ENDIF»
							«ENDIF»
						«ENDFOR»
						default: {
							none.push(this.visit(it));
						}
						break;
					}
				}
			}
		}
		«IF hasReturn»
			if (!ret.isEmpty()) {
				return ret;
			}
		«ENDIF»
		const node = «IF r.type === null»map«ENDIF»«IF r.type !== null»this.castTo«IF !hasMerge»List«ENDIF»(map, «itemClassName»)«ENDIF»
		«IF !hasMerge»
		return node;
		«ENDIF»
		«IF hasMerge»
		const ret = [];
		this.castToList(merge, «itemClassName»).forEach( (it:any) => {
			it.merge(node);
			ret.push(it);
		});
		return ret;
		«ENDIF»
	'''
	}

	def makeStringMethodBody(ParserRule r) '''
		const map = new Map<string, any>();
		const none = [];
		map.set("none", none);
		const n = node.childCount;
		for (let i = 0; i < n;++i) {
			const it = node.getChild(i);
			none.push(this.visit(it));
		}
		return map;
	'''


	def makeLiteralMethod(ParserRule r) '''
		«val methodName = "visit" + r.name.toCamelCase»
		public «methodName»(ctx:«r.name.toCamelCase»Context) {
			const findFirst = (ctx) => {
				const n = ctx.childCount;
				for (let i = 0; i < n;++i) {
					const it = ctx.getChild(i);	
					if (it instanceof TerminalNode) {
						«FOR it : r.eAllContents.filter(Element).toList»
							«IF it.op !== null»
								«IF it.op == "value"»
									if (it.symbol.type == «_grammarName»Parser.«it.terminalName») {
										return it;
									}
								«ENDIF»
							«ENDIF»
						«ENDFOR»
					}
				}
				return undefined;
			};
			const text = this.visit(findFirst(ctx)) as String;
			«IF r.type.type.name == "UniIntLiteral"»
				return new UniIntLiteral(Number(text));
			«ELSEIF r.type.type.name == "UniBoolLiteral"»
				return new UniBoolLiteral(Boolean(text));
			«ELSEIF r.type.type.name == "UniNoneLiteral"»
				return new UniNoneLiteral(text.substring(1, text.length - 1));				
			«ELSEIF r.type.type.name == "UniDoubleLiteral"»
				return new UniDoubleLiteral(Number(text));
			«ELSEIF r.type.type.name == "UniStringLiteral"»
				return new UniStringLiteral(text.substring(1, text.length - 1));
			«ELSEIF r.type.type.name == "UniCharacterLiteral"»
				return new UniCharacterLiteral(text.substring(1, text.length - 1));
			«ELSE»
				throw new RuntimeException("Unimplemented Method: «methodName»");
			«ENDIF»
		}
	'''

	def die(String message) {
		throw new RuntimeException(message)
	}

	def getInvokingState(ParserRule r) {
		_analyzer.getInvokingState(r)
	}

//	def hasItemClassField(ParserRule r, String itemClassName) {
//		val list = r.eAllContents.filter(Element).toIterable
//		for (elem : list) {
//			if (itemClassName.hasField(elem.op)) {
//				return true
//			}
//		}
//		return false
//	}
//
//	def hasField(String itemClass, String fieldName) {
//		try {
//			val clazz = Class.forName(UniNode.package.name + '.' + itemClass)
//			clazz.getField(fieldName)
//		} catch (Exception e) {
//			return false
//		}
//		return true
//	}

}
